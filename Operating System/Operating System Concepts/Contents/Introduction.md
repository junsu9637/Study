# 서론

> \- 컴퓨터 시스템의 일반적인 구성과 인터럽트의 역할         
  \- 현대 다중 처리기 컴퓨터 시스템의 구성요소             
  \- 사용자 모드에서 커널 모드로의 전환             
  \- 다양한 컴퓨팅 환경에서 운영체제의 사용 방식              
  \- 공개 소스 운영체제의 예             


**Operating System(운영체제)**
하드웨어를 관리하는 소프트웨어    
응용 프로그램을 위한 기반을 제공하며 컴퓨터 사용자와 컴퓨터 하드웨어 사이의 중재자 역할 수행

운영체제의 역할을 학습하기 위해서는 먼저 컴퓨터 하드웨어의 구성과 구조를 이해하는 것이 중요하다.

운영체제는 덩치가 크고 복잡하기 때문에 부분별로 생성 되어야 하고, 이 하나의 부분은 전체 시스템 윤곽에 잘 맞는 일부여야 한다.



# 차례
[1.1 운영체제가 할 일](#what-operating-system-do)          
[1.1.1 사용자 관점](#user-view)            
[1.1.2 시스템 관점](#system-view)                 
[1.1.3 운영체제의 정의](#operating-system-definitions)              

[1.2 컴퓨터 시스템의 구성](#computer-system-organization)             
[1.2.1 인터럽트](#interrupts)            
[1.2.2 저장장치 구조](#storage-structure)             
[1.2.3 입출력 구조](#io-structure)              

[1.3 컴퓨터 시스템의 구조](#computer-system-architecture)             
[1.3.1 단일 처리기 시스템](#single-processor-systems)           
[1.3.2 다중 처리기 시스템](#multiprocessor-systems)             
[1.3.3 클러스터형 시스템](#clustered-systems)             

[1.4 운영체제의 작동](#operating-system-operations)             
[1.4.1 멀티 프로그래밍과 멀티 태스킹](#multiprogramming-and-multitasking)              
[1.4.2 이중모드와 멀티모드 운용](#dualmode-and-multimode-operation)             
[1.4.3 타이머](#timer)             
           
[1.5 자원 관리](#resource-management)           
[1.5.1 프로세스 관리](#process-management)           
[1.5.2 메모리 관리](#memory-management)            
[1.5.3 파일 시스템 관리](#file-system-management)           
[1.5.4 대용량 저장장치 관리](#mass-storage-management)           
[1.5.5 캐시 관리](#cache-management)            
[1.5.6 입출력 시스템 관리](#io-system-management)          

[1.6 보안과 보안](#security-and-protection)

[1.7 가상화](#virtulization)

[1.8 분산 시스템](#distributed-systems)

[1.9 커널 자료구조](#kernel-data-structures)                  
[1.9.1 리스트, 스택, 큐](#lists-stacks-queues)              
[1.9.2 트리](#trees)             
[1.9.3 해시 함수와 맵](#hash-functions-and-maps)            
[1.9.4 비트맵](#bitmaps)         

[1.10 컴퓨팅 환경](#computing-environments)        
[1.10.1 전통적인 컴퓨팅](#tranditional-computing)              
[1.10.2 모바일 컴퓨팅](#mobile-computing)               
[1.10.3 클라이언트-서버 컴퓨팅](#client-server-computing)              
[1.10.4 피어 간 컴퓨팅](#peer-to-peer-computing)             
[1.10.5 클라우딩 컴퓨팅](#cloud-computing)               
[1.10.6 실시간 내장형 시스템](#real-time-embedded-systems)             

[1.11 무료 및 공개 오픈 운영체제](#free-and-opensource-operating-systems)                  
[1.11.1 역사](#history)             
[1.11.2 무료 운영체제](#free-operation-systems)           
[1.11.3 GNU/Linux](#gnu-linux)           
[1.11.4 BSD Unix](#bsd-unix)            
[1.11.5 Solaris](#solaris)                   
[1.11.6 학습 도구로서 오픈 소스 시스템](#open-source-systems-as-learning-tools)             




# What Operating System Do

운영체제가 수행하는 역할을 알아보기 전에 컴퓨터 시스템에 대한 논의부터 진행해야 한다. 컴퓨터 시스템은 4가지 구성요소인 **하드웨어, 운영체제, 응용 프로그램, 사용자**로 구분할 수 있다.

**하드웨어**            
> CPU(중앙 처리 장치), 메모리, I/O(입출력) 장치로 구성                        
  기본 계산용 자원 제공          

**응용 프로그램**                    
> 사용자의 계산 문제를 해결하기 위해 자원이 어떻게 사용될지 정의           
  위드 프로세서, 스프레드시트, 컴파일러, 웹 브라우저 등        

**운영체제**           
> 다양한 사용자를 위해 다양한 응용 프로그램 간의 하드웨어 사용을 제어 및 조정    
  자체로는 유용한 작업을 수행할 수 없음
  다른 프로그램이 유용한 작업을 할 수 있는 **환경** 제공
  
운영체제의 역할을 완전히 이해하기 위해서는 사용자와 시스템의 두 관점에서 살펴봐야 한다.

## User View

컴퓨터에 대한 사용자의 관점은 사용되는 인터페이스에 따라 달라진다.

*모니터, 키보드, 마우스로 구성된 PC*
> 한 사용자가 자원을 독점하도록 설계        
  운영체제 : 사용의 용이성을 위해 설계되고, 자원의 이용은 신경쓰지 않는다.
  
*가전제품 내 내장형 컴퓨터*
> 운영체제 : 사용자의 개입 없이 작동하도록 설계

## System View

컴퓨터의 관점에서 운영체제는 하드웨어와 가장 밀접하게 연관된 프로그램이다.

**운영체제**
> **Resource Allocator(자원 할당자)**         
  제 해결을 위해 요구되는 여러 자원(CPU 시간, 메모리 공간, 저장장치 공간 등)을 할당할지 결정       
  **Control Program(제어 프로그램)**         
  컴퓨터의 부적절한 사용을 방지하기 위해 사용자 프로그램의 수행을 저지

## Operating System Definitions

컴퓨터의 설계와 용도에 따라 수행해야할 역할과 기능이 달라지기 때문에 운영체제가 많은 역할과 기능을 수행해야 한다.

초기 컴퓨터       
목적 : 군사용, 정부 업무 등의 고정 목적 시스템          
특징 : 범용의 다기능 대형 컴퓨터로 발전 및 운영체제 등장

1960년대 무어의 법칙이 집적회로의 트랜지스터 수가 18개월마다 배로 늘어날 것으로 예측           
컴퓨터는 기능이 확대되고 크기가 작아지고, 용도가 다양화 되면서 다양한 운영체제 등장

**컴퓨터 시스템**의 기본 목표는 프로그램을 실행하고 사용자 문제를 쉽게 해결할 수 있게 만드는 것이다. 컴퓨터 **하드웨어**는 이러한 목표를 가지고 구성되지만 하드웨어 만으로는 사용하기가 쉽지 않아 **응용 프로그램**이 개발된다. 이러한 프로그램에는 특정 공통 작업이 필요하면서 자원을 제어하고 할당하는 **운영체제**가 개발된다.

따라서 운영체제는 적합한 정의나 운영체제에 포함되는 요소의 보편적인 정의가 없다. 운영체제는 단지 유용한 컴퓨팅 시스템을 만들기 위한 합리적인 방법을 제공하는 방식이다.

운영체제는 커널과 시스템 프로그램으로 구성된다. 종종 미들웨어를 포함하는 경우도 존재한다.
> 커널 : 컴퓨터에서 항상 실행되는 프로그램
  미들웨어 : 응요 프로그램 개발자에게 추가 서비스를 제공하는 소프트웨어 프레임워크
  
```markdown
운영체제
커널 + 미들웨어 프레임워크 + 시스템 프로그램
(항상 실행) + (응용 프로그램 개발 용이) + (시스템 관리)
```

# Computer-System Organization

현대의 범용 컴퓨터 시스템은 하나 이상의 CPU와 구성요소, 공유 메모리 사이의 엑세스를 제공하는 공통 **버스**를 통해 연결된 여러 장치 컨트롤러로 구성된다. 각 장치 컨트롤러는 특정 유형의 장치를 담당하지만, 컨트롤러에 따라 2개 이상의 장치가 연결될 수 있다. 

**장치 컨트롤러**        
> 일부 로컬 버퍼 저장소와 특수 목적 레지스터 집합 유지, 관리         
  제어하는 주변 장치와 로컬 버퍼 저장소간 데이터 이동    

일반적으로 운영체제에는 각 장치 컨트롤러마다 장치 드라이버가 있다.

**장치 드라이버**
> 장치 컨트롤러의 작동을 잘 알고, 운영체제와 장치 사이 인터페이스 역할

CPU와 장치 컨트롤러는 메모리에 대한 엑세스를 동기화한다. 이러한 시스템 작동방식의 3가지 주요 측면에 대해 살펴보자

## interrupts

일반적인 입출력을 수행하는 컴퓨터 작업은 아래와 같이 실행된다.
```markdown
1. 장치 드라이버는 장치 컨트롤러의 적절한 레지스터 값 적재
2. 장치 컨트롤러는 레지스터 내용을 검사해 수행할 작업 결정
3. 컨트롤러는 장치에서 로컬 버퍼로 데이터 전송 시작
4. 데이터 전송이 완료되면 장치 컨트롤러는 장치 드라이버에게 작업 완료 알림
5. 장치 드라이버는 제어권을 넘기거나 상태 정보를 반환
```

이때 컨트롤러는 **인터럽트**를 통해 장치 드라이버에게 작업을 완료했다는 사실을 알린다. 

### Overview

하드웨어는 어느 순간이든 시스템 버스를 통해 CPU의 신호를 보내 인터럽트를 발생시킬 수 있다. 따라서 인터럽트는 운영체제와 하드웨어의 상호 작용 방식의 핵심 부분이다.

CPU 인터럽트 발생
```markdown
1. CPU가 하던 작업을 중단하고 고정된 위치로 실행을 옮김
2. 인터럽트 서비스 루틴 시작(고정된 위치에 인터럽트 서비스 루틴 저장되어 있음)
3. 인터럽트 서비스 루틴 종료 시, DPU는 인터럽트 되었던 연산 재개
```

인터럽트는 컴퓨터 구조의 중요한 부분이기 때문에 각 컴퓨터 설계는 자신의 인터럽트 메커니즘을 가지고 있으며 몇 가지 기능은 공통으로 적절한 서비스 루틴으로 적절한 제어를 전달한다. 

인터럽트 루틴은 인터럽트 고유의 핸들러를 호출한다. 인터럽트는 매우 빈번하게 발생하기 때문에 이를 빠르게 처리되어야 한다. 필요한 속도를 위해 인터럽트 루틴에 대한 포인터들의 테이블을 대신 이용할 수 있어야 한다.

일반적으로 포인터들의 테이블은 하위 메모리에 저장된다. 이 위치에는 여러 장치에 대한 인터럽트 서비스 루틴의 주소가 들어 있다. 인터럽트가 요청되면, 인터럽트를 유발한 장치를 위한 인터럽트 서비스 루틴을 제공하기 위해 인터럽트 벡터(주소 배열)가 인터럽트 요청과 함께 주어진 고유 장치 번호로 색인된다. 

인터럽트 구조는 인터럽트 된 모든 정보를 저장해야 인터럽트를 처리한 후 이 정보를 복원할 수 있다. 

```markdown
1. 인터럽트 루틴이 처리기의 상태를 변경해야 한다면, 인터럽트 루틴은 현재 상태를 저장
2. 인터럽트를 서비스한 후 저장되어 있던 복귀 주소를 프로그램 카운터에 적재
3. 인터럽트에 의해 중단 되었던 연산 다시 실행
```

### Implementation

기본 인터럽트 메커니즘의 작동
```markdown
1. CPU 하드웨어는 **인터럽트 요청 라인**으로 명령어의 실행 완료를 감지
2. 실행 완료를 감지하면 인터럽트 번호를 읽고 이 번호를 인터럽트 벡터의 인덱스로 사용
3. 인덱스에 따라 **인터럽트 핸들러 루틴**으로 점프
4. 해당 인텍스와 관련된 주소에서 실행 시작
5. 인터럽트 처리기는 작업 중 변경될 상태를 저장, 인터럽트 원인 확인, 필요한 처리, 상태 복원 수행
6. **return_from-interrupt** 명령어 실행
7. CPU를 인터럽트 발생 전 실행 상태로 되돌린다.
7.1. 장치 컨트롤러가 인터럽트 요청 라인에 신호를 선언하여 인터럽트 **발생(raise)**
7.2. CPU가 인터럽트를 **포착(catch)** 하여 인터럽트 핸들러로 **디스패치(dispatch)**
7.3 핸들러는 장치를 서비스하여 인터럽트 **지움(clear)**
```

**인터럽트 컨트롤러 하드웨어**는 보다 정교한 인터럽트 처리 기능을 제공한다
> \-중요한 처리 중 인터럽트 연기          
  \-장치의 적절한 인터럽트 핸들러로 효율적으로 디스패치               
  \-우선순위에 따라 인터럽트를 구별               
  \-긴급도로 대응할 수 있도록 다단계 인터럽트 구축            

대부분의 CPU에는 2개의 인터럽트 요청 라인이 있다.
> **마스킹 불가능 인터럽트** : 메모리 오류와 같은 이벤트를 위해 예약하기 위해 사용
  **바스킹 가능 인터럽트** : 장치 컨트롤러가 서비스를 요청하기 위해 사용

벡터 방식 인터럽트 기법의 목적은 서비스가 필요한 장치를 결정하기 위해 하나의 인터럽트 핸들러가 가능한 모든 인터럽트 소스를 검색할 필요를 줄이는 것이다. 그러나 실제 컴퓨터에는 인터럽트 벡터의 주소 개수보다 많은 장치(인터럽트 처리기)가 있다. 따라서 **인터럽트 체인**을 사용한다.

**인터럽트 체인**
큰 크기의 인터럽트 테이블의 오버헤드와 하나의 인터럽트 핸들러로 디스패치 하는 비효율성의 절충안
```markdown
1. 인터럽트 벡터의 각 원소는 인터럽트 핸들러 리스트의 헤드를 가리킨다.
2. 인터럽트가 발생하면 요청을 처리할 수 있는 핸들러가 발견될 때까지 상응하는 리스트의 핸들러가 하나씩 호출
```

인터럽트 기법은 인터럽트 **우선순위 레벨**을 구현한다. 이러한 레벨을 통해 CPU는 모든 인터럽트를 마스킹하지 않고도 우선순위가 낮은 인터럽트 처리를 연기할 수 있고, 우선순위가 높은 인터럽트를 선점할 수 있다. 

```markdown
인터럽트        
최신 운엥체제에서 비동기 이벤트를 처리하기 위해 사용            
장치 컨트롤러 및 하드웨어 오류로 인해 발생             
가장 긴급한 작업을 먼저 처리하기 위해 우선순위 시스템 사용             
시스템 성능을 좋게 하려면 효율적인 인터럽트 처리가 필요           
```

## Storage Structure

CPU는 메모리에서만 명령을 적재할 수 있으므로 CPU가 실행하려면 먼저 메모리에 프로그램을 적재해야한다. 범용 컴퓨터는 프로그램 대부분을 **메인 메모리(RAM)** 라고 불리는 재기록 가능한 메모리에서 가져온다. 

RAM은 휘발성이기 때문에 컴퓨터 전원을 켤 때 실행되어 운영체제를 적재시키는 **부트스트랩 프로그램**을 유지하는 용도로는 사용할 수 없다. 따라서 컴퓨터는 전기적으로 소거 가능한 프로그램 읽기 전용 메모리(EEPROM) 및 기타 **펌웨어**(쓰기 작업이 자주 발생하지 않고 비휘발성인 저장장치)를 사용한다. 

모든 형태의 메모리는 바이트의 배열을 제공한다. 각 바이트는 자신의 주소를 가지고 있고, 상호 작용은 특정 메모리 주소들에 대한 **load(적재)**, **store(저장)** 명령어를 통해 이루어진다. 그리고 CPU는 프로그램 카운터에 저장된 위치로부터 실행하기 위해 메인 메모리로 명령을 자동으로 적재한다.
> Load : Main Memory -> CPU 내부 레지스터로 한 바이트 혹은 한 워드를 옮김
  Store : CPU 내부 레지스터 -> Main Memory로 한 바이트 혹은 한 워드를 옮김
  
**폰 노이만 구조 시스템**에서 실행되는 명령-실행 사이클은 아래와 같다
```markdown
1. 메모리로부터 명령어를 인출
2. 명령을 Instruction Register(명령어 레지스터)에 저장
3. 명령 해독
4. 메모리로부터 피연산자를 인출
5. 피연산자를 내부 레지스터에 저장
6. 결과를 메모리에 저장
```

이 과정에서 메모리는 메모리 주소만을 인식한다는 것에 주목해야한다. 메모리는 주소*[Instruction Counter(명령 카운터), (Indexing)색인, (Indirection Addresses)간접주소, (Literal Addresses)리터럴 주소]* 가 어떻게 생성되었는지 알지 못하고, 명령인지 데이터인지 알지 못한다. 따라서 우리는 메모리 주소가 프로그램에 의해 어떻게 생성되었는지 무시할 수 있고, 메모리 주소에만 집중하면 된다.

메인메모리에 프로그램이 영구적으로 존재하면 좋겠지만, 메인 메모리의 저장 용량이 부족하고, 비휘발성이기 때문에 전원 공급이 중단되면 데이터가 소멸되기 때문에 영구저장이 불가능한다. 

따라서 대부분의 컴퓨터 시스템은 메인 메모리의 확장으로 **보조기억장치**를 사용한다. 보조기억장치는 대량의 데이터를 영구히 보존할 수 있다. 대표적으로 하드 디스크 드라이버(HDD), 비휘발성 메모리(NVM)이 있다. 대부분의 프로그램은 메모리에 적재될 때까지 보조기억장치에 저장된다. 보조기억장치는 메인 메모리보다 휠씬 느리기 때문에 2차 저장장치의 올바른 관리가 중요하다.


**저장장치 계층 구조**
```markdown
1차 저장장치 : 휘발성 저장장치
(레지스터 > 캐시 > 메인 메모리)
2차 저장장치 : 비휘발성 저장장치
(NVM > HDD)
3차 저장장치 : 특수 목적 저장장치
(광학 디스크 > 자기 테이프)
```

위 계층 구조에서 메모리가 작고 빠를수록 CPU에 가깝다. 최상위 4단계 메모리(레지스터~NVM)는 반도체 기반 전자회로로 구성된 **반도체 메모리**를 사용하여 구성된다. 보통 휘발성 저장장치를 메모리라고 표현하고, 비휘발성 저장장치를 NVS라고 표현한다. 대부분의 경우 NVS는 보조기억장치를 가리키는데 NVS는 기계적과 전기적으로 분류한다.

> **기계적 NVS**        
  HDD, 광 디스크, 자기 테이프 등            
  **전기적 NVS(=NVM)**            
  SSD, 플래시 메모리, FRAM, NRAM 등           

## Io structure

운영체제에서 시스템의 안정성과 성능이 가장 중요한 부분이다. 이러한 이유를 운영체제 코드의 상당 부분은 I/O 관리에 할애한다. 

컴퓨터 시스템은 범용 버스를 통해 데이터를 교환하는 여러 장치로 구성된다. 인터럽트 구동 I/O의 경우 소량의 데이터를 이동하는 데는 좋지만 NVS I/O와 같은 대량 데이터 이동에 사용될 때 높은 오버헤드를 유발할 수 있다. 이러한 문제를 해결하기 위해 **직접 메모리 엑세스(DMA)** 가 사용된다. 이 방법의 진행 과정은 다음과 같다.

```markdown
1. 장치에 대한 버퍼, 포인터, 입출력 카운터 설정
2. 장치 제어기는 CPU의 개입 없이 메모리로부터 자신의 버퍼 장치로 또는 버퍼로부터 메모리로 데이터 블록 전체 전송
3. 블록 전송이 완료될 때마다 인터럽트 발생
4. 장치 제어기가 전송 작업을 수행하고 있는 동안 CPU는 다른 작업 수행
```

몇몇 고가의 시스템은 버스 대신 스위치 구조를 사용해서 공유 버스를 사용하기 위한 사이클 경쟁을 없애고, 다수의 구성요소가 다른 구성요소들과 동시에 통신하는 것이 가능하다. 이 경우 DMA의 사용 효과가 증가한다. 

# Computer-System Architecture

컴퓨터 시스템은 사용된 범용 프로세서의 수에 따라 분류 가능한 다양한 방식으로 구성된다.

## Single-Processor Systems

단일 프로세서 시스템은 단일 코어를 가진 하나의 CPU를 포함하는 단일 프로세스를 사용한다. 여기서 코어는 명령을 실행하고 로컬로 데이터를 저장하기 위한 레지스터를 표함하는 구성요소다. 코어를 가진 하나의 메인 CPU는 프로세스의 명령어를 포함하여 범용 명령어 세트를 실행할 수 있다. 

이 시스템에는 다른 특수 목적 프로세서도 포함되는데 이 모든 전용 프로세서들은 제한된 명령어 집합을 실행하고 사용자 프로세스를 실행하지 않는다. 운영체제는 이 프로세스들이 수행할 다음 작업에 대한 정보를 보내고 프로세서 상태를 감시한다. 운영체제는 이 프로세서들과 통신할 수 없으며 이 프로세서들은 독립적으로 자신의 작업을 처리한다. 

## Multiprocessor Systems

### 단일 코어 시스템

다중 프로세스 시스템은 각각 단일 코어 CPU가 있는 2개 이상의 프로세서가 있다. 프로세서는 컴퓨터 버스, 클록, 메모리, 주변장치를 공유하면서 정보 처리량을 증가시킨다. 그러나 여러 프로세서가 하나의 작업을 수행할 때, 모든 프로세서가 일정하게 작동하는 것이 아니기 때문에 N 프로세서의 속도 향상 비율은 N 배가 아니다. 

가장 일반적인 다중 프로세서 시스템은 각 CPU 프로세서가 운영체제 기능과 사용자 프로세스를 포함한 모든 작업을 수행하는 **SMP(Symmetric MultiProcessing)** 를 사용한다. 이 모델은 각 CPU 처리기에는 개별 캐시, 자체 레지스터가 있지만 모든 프로세서는 시스템 버스를 통해 물리 메모리를 공유한다. 

이 모델의 장점은 많은 프로세스를 동시에 실행할 수 있다는 것이다. 그러나 CPU가 독립적이기 때문에 특정 하나가 과부화에 걸려 비효율적일 수 있다. 이러한 문제는 프로세서가 특정 자료구조를 공유하거나 자원을 다양한 프로세서간 동적 공유를 수행한다면 해결할 수 있다. 

### 다중 코어 시스템

다중 프로세서의 정의는 시간이 지남에 따라 발전해 왔고, 현재는 여러 개의 컴퓨팅 코어가 단일 칩에 상주하는 **다중 코어 시스템**을 포함한다. 칩 내 통신이 칩 간 통신보다 빠르기 때문에 다중 코어 시스템은 단일 코어 시스템보다 속도가 빠르고, 전력 소모가 적다.

다중 코어 시스템의 설계에서 각 코어에는 자체 레지스터와 공유 레지스터로 구성된다. 자체 레지스터는 L1 캐시 혹은 자체 로컬 캐시라고 부른다. 공유 레지스터는 L2 캐시라고 부르며 코어들끼리 데이터를 공유한다. 대부분의 아키텍쳐는 L1 캐시와 L2 캐시를 결합한 방식을 사용한다. 

### NUMA

CPU의 개수를 추가하면 컴퓨팅 성능이 향상되지만, CPU를 너무 많이 추가하면 시스템 버스에 대한 병목 현상과 같은 문제가 발생한다. 이러한 문제를 해결하기 위해서는 CPU에 작고 빠른 로컬 버스를 통해 엑세스 되는 자체 로컬 메모리를 제공하는 것이다. 이렇게 모든 CPU가 **공유 시스템**으로 연결되어 하나의 물리 주소 공간을 공유하는 방법을 **NUMA(Non-Uniform Memory Access)** 라고 한다. 이 시스템은 CPU가 로컬 메모리에 엑세스 할 때 속도가 빠르고, 시스템 상호 연결에 대한 경합이 없다. 따라서 NUMA 시스템은 많은 프로세서가 추가될수록 더 효과적으로 확장할 수 있다.

하지만 CPU가 시스템 상호 연결을 통해 원격 메모리에 엑세스해야 할 때 지연 시간이 증가하는 문제가 있다. 즉 CPU<sub>0</sub>가 자체 로컬 메모리에 엑세스 하는 것보다 CPU<sub>3</sub>의 로컬 메모리에 엑세스하는 속도가 월등하게 느리다. 이런 문제는 CPU 스케줄링, 메모리 관리를 통해 최소화할 수 있다. 

### 블레이드 서버

**블레이드 서버**는 다수의 프로세서 보드, 입출력 보드, 네트워킹 보드를 하나의 **Chassis** 안에 저장되는 형태로 구성된다. 이 시스템은 각 보드들이 독립적인 운영체제를 포함하고 있다. 

## Clustered Systems

클러스터형 시스템은 둘 이상의 독자적 시스템 또는 노드들을 연결하여 구성한다. 여기서 노드는 다중 코어 시스템을 의미한다. **클러스터형**의 정의는 분명하지 않다. 일반적으로 받아들여지는 정의는 클러스터 컴퓨터는 저장장치를 공유하고 근거리 통신망이나 고속 상호 연결망을 통해 연결다는 것이다. 한 클러스터가 네트워크로 연결된 다수의 컴퓨터 시스템으로 구성되므로 클러스터는 **고성능 계산 환경**을 제공할 수 있다.

이를 위해서는 응용 프로그램이 클러스터를 이용할 수 있게 작성되야한다. 이는 **병렬화**라는 기법으로 프로그램을 클러스터의 각 컴퓨터에서 수행되는 분리된 요소로 나누는 작업을 수행한다. 이를 통해 응용 프로그램은 클러스터의 각 계산 노드가 문제의 일부를 해결한 후 모든 노드의 결과를 결합하여 최종 결과를 산출한다.

클러스터링은 **높은 가용성**을 제공하기 위해 사용된다. 즉 클러스터 내 특정 컴퓨터 시스템이 고장 나더라도 서비스는 계속 제공된다. 이러한 높은 가용성은 시스템에 중복 기능을 추가함으로써 얻어진다. 
```markdown
1. 클러스터 소프트웨어 중 한 층이 클러스터 노드에서 실행된다.
2. 각 노드는 하나 이상의 노드들을 감시한다.
3. 감시받던 노드가 고장나면 그 노드의 저장장치 소유권을 넘겨받는다.
4. 고장난 노드에서 실행 중이던 응용 프로그램을 다시 시작한다.
```

이렇게 시스템 내부의 단일 구성요소에 오류가 발생하여도 계속 작동할 수 있으므로 **결함허용 시스템**이라고도 한다. 

### 비대칭형 클러스터링

다른 컴퓨터들이 응용 프로그램을 실행하는 동안 한 컴퓨터는 **긴급 대기 모드(Hot-Standby)** 상태를 유지한다. 이 긴급 대기 모드는 활성 서버들을 감시하는 작업만 수행한다. 서버가 고장나면 긴급 대기 모드의 호스트가 활성 서버가 된다.

### 대칭형 클러스터링

둘 이상의 호스트들이 응용 프로그램을 실행하고 서로를 감시한다. 가용한 하드웨어를 모두 사용하기 때문에 보다 효율적이다. 대칭형 구성이 효율적으로 동작하기 위해서는 하나 이상의 응용 프로그램들이 실행 가능해야 한다. 

### 병렬 + WAN 클러스터링

여러 호스트가 공유 저장장치상의 동일한 데이터에 접근할 수 있게 구성한다. 운영체제의 대부분이 여러 호스트에 의한 동시 접근을 지원하지 않기 때문에 병렬 클러스터는 특수 소프트웨어 버전을 사용한다. 예를 들어 Oracle Real Application Cluster이 있다.
```markdown
1. 각 코어는 데이터베이스 내의 모든 데이터에 대한 완전한 접근을 한다.
2. 시스템은 접근 간의 충돌이 발생하지 않게 접근 제어와 잠금 기법을 제공한다. 
(이러한 기능은 DLM(분산 잠금 관리자)라고 부르며 클러스터 소프트웨어에 포함된다.)
```

### 병렬 + SAN 클러스터링

SAN(스토리지 전용 네트워크)를 사용하여 한 클러스터 내에 수천 개의 노드를 지원한다. 응용 프로그램과 데이터가 SAN에 저장된다면 클러스터 소프트웨어는 SAN에 연결된 임의의 호스트에게 배정할 수 있다. 또한 수십 개의 호스트가 동일한 데이터베이스를 공유할 수 있기 때문에 성능과 신뢰도를 크게 증가시킨다. 

# Operating System Operations

운영체제는 프로그램이 실행되는 환경을 제공한다. 앞서 언급한 컴퓨터가 시작할 때 실행되는 부트스트랩 프로그램의 경우 컴퓨터 하드웨어 내에 펌웨어로 저장된다. 부트스트랩은 CPU레지스터에서 메모리 내용까지 모든 시스템을 초기화 한다. 이런 작업을 위해서는 부트스트랩 프로그램이 운영체제 커널을 찾아 메모리에 적재되어야 한다. 

커널이 적재되어 실행되면 시스템과 사용자에게 서비스를 제공할 수 있다. 일부 서비스는 커널이 실행되는 전체 시간 동안 실행되는 **시스템 데몬**이 되기 위해 부팅할 때 메모리에 적재되는 시스템 프로그램에 의해 커널 외부에서 제공된다. 

실행할 프로세스, 서비스할 I/O, 응답할 사용자가 없는 경우 운영체제는 다음 작업을 기다린다. 이벤트가 발생하면 인터럽트를 발생시켜 운영체제에 신호를 보낸다. 그리고 **트랩**(오류 또는 사용자 프로그램의 특정 요청으로 인해 발생하는 소프트웨어 생성 인터럽트)이 발생하면 **시스템 콜**이라는 특수 연산을 실행할 것을 운영체제에게 요청한다.

## Multiprogramming and Multitasking

### 멀티 프로그래밍
멀티 프로그래밍은 CPU가 항상 한 개는 실행할 수 잇도록 프로그램을 구성하여 CPU 이용률을 높이는 운영체제의 기능이다. 멀티 프로그램 시스템에서 실행 중인 프로그램을 **프로세스**라고 한다.

운영체제는 여러 프로세스를 동시에 메모리에 적재한다. 이러한 프로세스 중 하나를 선택하여 시작한다. 만일 해당 프로세스가 대기해야 하는 경우, 다른 프로세스로 전환한다. 

### Multitasking
멀티 태스킹은 다중 프로그래밍의 논리적 확장으로서 시스템에서 CPU는 여러 프로세스를 전환하며 프로세스를 실행하지만 전환일 자주 발생하여 빠른 응답 시간을 제공한다. 

동시에 여러 프로세스를 메모리에 적재하려면 메모리 관리와 프로세스 관리가 필요하다. 이를 위해서 CPU 스케줄링, 프로세스 스케줄링 등이 필요하다. 

빠른 응답 시간을 보장하기 위해서 운영체제는 가상 메모리를 사용한다.

또한 파일 시스템 관리, 프로세스 동기화, 저장장치 관리 등의 기술들이 필요하다. 

## Dualmode and Multimode Operation

### 이중 모드
운영체제와 사용자는 컴퓨터 시스템의 자원을 공유하기 때문에 잘못된 프로그램으로 인해 다른 프로그램 또는 운영체제 자체가 잘못 실행될 수 있다. 따라서 운영체제는 사용자 정의 코드 실행을 구분 지어야한다. 이를 위해 **사용자 모드**와 **커널 모드(관리자 모드, 특권 모드)** 로 구분한다. 이 두가지 모드는 **모드 비트**라고 하는 하나의 비트를 추가하며 구분한다. 커널모드는 0, 사용자 모드는 1을 부여한다. 

```markdown
1. 시스템 부팅
2. 커널 모드 실행
3. 운영체제 적재
4. 사용자 모드에서 사용자 프로세스가 실행
5. 인터럽트나 트랩이 발생할 때마다 사용자 모드에서 커널 모드로 전환
6. 사용자 프로그램으로 제어를 넘기기 전에 커널 모드에서 사용자 모드로 전환
```

이중 모드는 운영체제와 사용자를 보호하기 위해 일부 명령을 **Privileged Instruction(특권 명령)** 으로 지정한다. 하드웨어는 특권 명령이 커널 모드에서만 수행되도록 허용한다. 사용자 모드에서 특권 명령을 수행하려고 시도하면, 하드웨어는 이를 실행하지 않고 운영체제로 트랩을 건다. 

###  모드
모드의 개념은 두 가지 모드 이상으로 확장할 수 있다. 
> Intel : 4개의 보호링(0 : 커널 모드, 1,2 : 다양한 운영체제 서비스, 3: 사용자 모드)           
  ARMv8 : 7개의 모드
  
가상화를 지원하는 CPU는 종종 **VMM(Vartual Machine Manager)** 이 시스템을 제어하는 시점을 표시하기 위한 별도의 모드를 가진다. 이 모드에서 VMM은 사용자 프로세스보다 많은 권한을 가지지만 커널보다는 적은 권한을 갖는다. 

### 시스템 콜
시스템 코른 사용자 프로그램이 자신을 대신하여 운영체제가 수행하도록 지정되어 있는 작업을 운영체제에 요청할 수 있는 방법을 제공한다. 시스템 콜은 컴퓨터 시스템의 처리기가 지원하는 기능에 따라 다양한 방법으로 호출된다. 

시스템 콜이 수행될 때, 시스템 콜은 하드웨어에 의해 하나의 소프트웨어 인터럽트로 취급된다. 
```markdown
1. 제어가 인터럽트 벡터를 통해 운영체제 내의 서비스 루틴으로 전달
2. 모드 비트가 커널 모드로 설정
```
즉 시스템 콜 서비스 루틴은 운영체제의 일부이다. 커널은 인터럽트를 발생시킨 명령을 검사하여 어떤 시스템 콜이 발생했는지를 결정한다. 이 때 전달된 인수가 사용자 프로그램이 요청하는 서비스 유형을 표시한다. 

### 하드웨어 보호
하드웨어 보호 기능은 모드 규칙을 위반하는 오류를 하드웨어에 의해 탐지한다. 이러한 오류는 일반적으로 운영체제가 처리한다. 
```markdown
1. 사용자 프로그램이 불법적인 접근 시도
2. 하드웨어는 운영체제로 트랩 발생
3. 트랩은 인터럽트 벡터를 통해 제어를 운영체제로 넘김
4. 프로그램 오류가 발생할 때마다 운영체제는 프로그램 종료
5. 적절한 오류 메세지가 주어지고, 프로그램의 메모리가 덤프된다.
6. 덤프된 메모리는 사용자가 조사하여, 통상 파일에 기록한다. 
```
 
## timer

타이머는 운영체제가 CPU에 대한 제어를 유지할 수 있도록 다음과 같은 기능을 제공한다.
> 프로그램이 무한 루프에 빠지지 않게 한다.        
  시스템 서비스 호출에 실패하여 제어가 운영체제로 복귀하지 않는 경우 방지
 
타이머는 지정된 시간이 지나면 컴퓨터를 강제로 인터럽트 하도록 설정할 수 있다. 타이머 값을 설정하는 명령은 특권 명령이다. 

운영체제는 사용자에게 제어를 양도하기전에 타이머가 인터럽트 할 수 있도록 설정되었는지를 확인한다. 만약 타이머가 인터럽트를 발생하면 제어는 자동으로 운영체제에 넘어간다. 이때 운영체제는 이 인터럽트를 오류로 취급하거나 프로그램에 더 많은 시간을 할당할 수 있다. 
 
**가변 타이머**는 일반적으로 고정률의 클록과 계수기로 구현한다.
```markdown
1. 운영체제는 계수기 값을 설정
2. 클록이 진행됨에 따라 계수기 갑소
3. 계수기가 0이되면 인터럽트 발생
```

# Resource Management

운영체제는 컴퓨터 자원을 관리하기 때문에 **자원 관리자**라고도 부른다.

## Process Management

프로그램은 CPU에 의해 명령이 실행되지 않으면 아무것도 할 수 없다. 프로세스는 본인의 일을 수행하기 위해 여러 자원들이 필요하다. 프로세스가 생성될 때 획득하는 물리,논리적 자원 외, 여러 초기화 데이터(입력)도 전달될 수 있다. 예를 들어 웹 페이지의 내용을 화면에 표시하는 웹 브라우저를 실행하는 프로세스는 다음과 같이 실행된다.

```markdown
1. 프로세스는 URL을 입력으로 제공받는다.
2. 적절한 명령과 시스템 콜을 실행한다.
3. 적절한 정보를 화면에 표시한다.
4. 프로세스가 종료되면 운영체제는 재사용 가능한 자원을 회수한다.
```

여기서 프로그램과 프로세스가 다르다는 것을 반드시 해야 한다.
> **프로그램**     
  디스크에 저장된 파일의 내용과 같은 **수동적 개체**      
  **프로세스**           
  다음 명령을 지정하는 Program Counter을 지닌 **능동적 개체**

한 프로세스의 수행은 반드시 순차적이여야 한다. CPU는 프로세스가 끝날 때까지 그 프로세스의 명령을 차례대로 수행하고, 그 프로세스를 위해 하나의 명령만 수행하는 경우도 있다. 이런 문제를 방지하기 위해 개발된 다중 스레드 프로세스는 여러 PC를 사용해서 각 스레드가 실행할 다음 명령어를 가리키게 된다.

한 프로세스는 한 시스템 내의 작업의 단위이다. 이러한 시스템은 프로세스의 집합으로 구성된다. 이는 시스템 프로세스와 사용자 프로세스로 이루어진다. 이러한 모든 프로세스는 단일 CPU 코에에서 멀티플렉싱을 하거나 다중 CPU 코어에서 병렬로 병행하게 실행할 수 있다. 

운영체제는 프로세스 관리에 있어서 다음과 같은 역할을 맡는다.
```markdown
1. 사용자 프로세스와 시스템 프로세스의 생성과 제거
2. CPU에 프로세스와 스레드 스케줄링
3. 프로세스의 일시 중지와 재수행
4. 프로세스 동기화를 위한 환경 제공
5. 프로세스 통신을 위한 환경 제공
```

## Memory Management

메인 메모리는 CPU와 입출력 장치에 의해 공유되는 빠른 접근이 가능한 데이터 저장소다. 폰 노이만 컴퓨터에서 메모리 접근은 다음과 같다.
```markdown
1. CPU가 명령어 인출 사이클동안 메인 메모리로부터 명령어를 읽는다.
2. CPU가 데이터 인출 사이클동안 메인 메모리로부터 데이터를 읽는다.
```

메인 메모리는 일반적으로 CPU가 직접 주소를 지정할 수 있고, 직접 접근할 수 있는 유일한 대용량 메모리다. 예를 들어 CPU가 디스크에서 가져온 데이터를 처리하려면 CPU가 생성한 입출력 호출에 의해 먼저 메인 메모리로 전송 되어야 한다. 그리고 CPU가 명령을 수행하기 위해서는 명령이 메인 메모리 내에 있어야 한다. 

프로그램 수행은 다음과 같이 진행된다.
```markdown
1. 프로그램을 주소에 매핑되고 메모리에 적재시킨다. 
2. 생성된 주소를 통해 프로그램 명령어와 데이터에 접근한다.
3. 프로그램 종료
4. 프로그램이 차지하던 메모리 공간을 가용공간으로 선언한다.
5. 다음 프로그램이 적재된다.
```

CPU 이용률과 사용자에 대한 컴퓨터의 응답 속도를 개선하기 위해 우리는 메모리에 여러 프로그램을 유지한다. 이를 위해서는 **메모리 관리 기법**이 필요하다. 메모리 관리 기법은 메모리 관리에 대한 여러 접근 방법을 반영한다. 이는 각 알고리즘의 효율성과 특정 상황에 따라 다르다. 각 알고리즘은 자기를 위한 하드웨어의 자원이 필요하기 때무넹 특정 시스템에 대한 메모리 관리 기법의 선택은 보통 시스템의 하드웨어 설계에 의해 결정된다. 

운영체제는 메모리 관리에 있어서 다음과 같은 역할을 맡는다.
```markdown
1. 현재 메모리의 어느 부분이 사용되고 있는지, 어느 프로세스에 의해 사용되고 있는지 추적
2. 필요에 따라 메모리 공간을 할당하고 회수
3. 어떤 프로세스들을 메모리에 적재하고 제거할 것인지 결정
```

## File-System Management

운영체제는 컴퓨터 시스템의 편리한 사용을 위해 정보 저장장치에 대한 균일한 논리적 관점을 제공해야 한다. 이를 위해 저장장치의 물리적 특성을 추상화하여 논리적인 저장 단위인 **파일**을 정의한다. 그리고 파일을 물리적 매체로 매핑하여 저장장치를 통해 파일에 접근한다.

컴퓨터는 여러 유형의 물리적 매체에 정보를 저장할 수 있다. 각 매체는 자신의 특성(접근 속도, 용량, 데이터 전송률 등)과 물리적 구성을 가지고 있다.

**파일**은 파일 생성자에 의해 정의된 관련 정보의 집합체다. 일반적으로 파일은 프로그램과 데이터를 나타낸다. 파일은 사용하기 쉽도록 통상 디렉토리들로 구성된다. 운영체제는 대량 저장 매체와 그것을 제어하는 장치를 관리함으로써 파일의 추상적인 개념을 구현한다. 다수의 사용자가 파일에 접근하려고 할 때는 파일에 접근하는 방법과 접근 인물을 통제하는 것이 바람직하다.

운영체제는 파일 관리에 있어서 다음과 같은 역할을 맡는다.
```markdown
1. 파일의 생성 및 제거
2. 디렉터리 생성 및 제거
3. 파일과 디렉터리를 조작하기 위한 프리미티브 제공
4. 파일을 보조저장장치로 매핑
5. 비휘발성 저장 매체에 파일 백업
```

## Mass-Storage Management

컴퓨터 시스템은 메인 메모리를 백업하기 위해 보조기억장치를 제공해야 한다. 보조저장장치는 빈번하고 폭넓게 사용되므로 효율적으로 사용되어야 한다. 컴퓨터의 전체 동작 속도는 보조저장장치 서브시스템과 그것을 조작하는 알고리즘의 속도에 의해 결정될 수 있다. 

운영체제는 보조저장장치 관리에 있어서 다음과 같은 역할을 맡는다.
```markdown
1. 마운팅과 언마운팅
2. 사용 가능 공간의 관리
3. 저장장소 할당
4. 디스크 스케줄링
5. 저장장치 분할
6. 보호
```

## Cache Management

정보는 저장장치에 보관되고, 정보가 사용되면서 더 빠른 장치인 **캐시**에 일시적으로 복사된다. 따라서 우리가 특정 정보가 필요한 경우. 캐시에 그 정보가 있는지를 조사해야 한다. 만약 캐시에 정보가 있다면 캐시로부터 직접 사용하고, 캐시에 없다면 메인 메모리 시스템으로부터 정보를 가져와서 캐시에 복사하고 사용한다. 

컴퓨터 시스템의 대부분은 다음에 수행될 것으로 예상되는 명령을 넣어 두는 **명령 캐시**를 가지고 있다. 만약 명령이 없다면 CPU는 메인 메모리로부터 다음 명령을 인출해 올 몇 사이클을 기다려야 한다. 

캐시 크기가 제한되어 있으므로 캐시 관리는 매우 중요한 문제이다. 저장장치의 계층 구조에서 각 영역 간의 정보 이동은 하드웨어 설계나 제어하는 운영체제에 따라 명시적으로 이루어진다. 예를 들어 캐시로부터 CPU 및 레지스터로의 데이터 전송은 하드웨어적으로 이루어진다. 하지만 디스크와 메모리 간의 데이터 전송은 운영체제에 의해 제어된다. 

메모리 계층 구조에서 동일한 데이터가 서로 다른 영역의 저장장치 시스템에 나타나게 된다. 예를 들어 디스크에 저장되어 있는 A라는 변수를 변경하는 과정은 다음과 같다.
```markdown
1. A가 있는 디스크 블록을 메인 메모리로 복사하는 입출력 연산 호출
2. A가 있는 메인 메모리 블록을 캐시로 복사하는 입출력 연산 호출
3. A가 있는 캐시 블록을 CPU 레지스터로 복사하는 입출력 연산 호출
4. 연산 진행
5. 디스크에 새로운 A 값 기록
```

하나의 프로세스만 실행하는 환경에서 이러한 기법은 문제가 없다. 하지만 CPU가 여러 프로세스 사이에서 멀티태스킹 되는 환경에서는 여러 프로세스가 A에 접근할 때는 문제가 발생한다. 뿐만 아니라 CPU가 내부 레지스터를 유지할 뿐만 아니라 로컬 캐시도 갖고 있는 멀티 프로세스 환경에서는 문제가 더욱 복잡해진다. 이러한 상황을 **캐시 일관성 문제**라고 한다.  

## IO System Management

운영체제는 사용자에게 측정 하드웨어 장치의 특성을 숨겨야 한다. 효율적인 입출력 서브시스템을 구성하기 위해서는 인터럽트 핸들러와 장치 드라이버에 대한 논의가 진행되어야 한다. 

따라서 입출력 시스템은 다음과 같이 구성되어 있다. 
```markdown
1. 버퍼링, 캐싱, 스풀링을 포함한 메모리 관리 구성요소
2. 일반적인 장치 드라이버 인터페이스 관리
3. 특정 하드웨어 장치들을 위한 드라이버
```

# Security and Protection

컴퓨터 시스템이 다수의 사용자를 가지며 다수 프로세스의 병행 수행을 허용한다면 데이터에 대한 접근은 반드시 규제되어야 한다. 이를 위해 파일, 메모리, 세그먼트, CPU 및 다른 자원들에 대해 운영체제로 부터 적절한 허가를 획득한 프로세스만이 작업할 수 있는 환경을 조성해야한다. 이러한 환경을 조성하기 위한 기법으로는 보호와 보안이 있다.

보호와 보안을 제공하기 위해서는 시스템의 모든 사용자를 구분할 수 있어야 한다. 운영체제는 대부분의 사용자 이름과 관련된 **User ID(사용자 식별자)** 리스트를 유지한다. windows에서는 **SID(Security ID(보안 식별자))** 라고도 한다. 

이 식별자는 사용자마다 할당되고 시스템에서 유일한 값을 가진다. 사용자가 로그인 할 때 인증 단계에서 사용자에게 맞는 적절한 식별자를 결정한다. 이 사용자 식별자는 사용자의 모든 프로세스나 스레드에 연관된다. 식별자를 사용자가 읽어야 할 필요가 있을 때는 사용자 이름 리스트를 통해 원래 사용자 이름으로 변경한다. 

그리고 상황에 따라 각 사용자의 집합을 구분하기 위해서 그룹 이름과 그 그룹에 속한 사용자들을 정의할 필요가 있다. 그룹 기능은 시스템 전체에 존재하는 그룹 이름과 **그룹 식별자**의 리스트로 구현될 수 있다. 사용자는 운영체제를 설계했을 때의 결정에 따라 하나 이상의 구룹에 속할 수 있다. 

시스템을 정상적으로 사용하는 동안 사용자 식별자와 그룹 식별자만 있으면 충분하다. 하지만 사용자는 때때로 원하는 작업을 수행하기 위해 권한을 상승해야 할 때가 있다. 이럴 때 운영체제는 권한 상승을 허용하는 다양한 방법을 제공한다. 이를 위해 프로세스는 종료되거나 특권을 해제하기 전까지 Effective User ID(유효 사용자 식별자)를 통해 작업을 수행한다. 

## Protection

**보호**란 컴퓨터 시스템이 정의한 자원에 대해 프로그램, 프로세스, 사용자들의 접근을 제어하는 기법이다. 이 기법은 실행될 제어에 대한 명세와 이들을 강제 시행하는 방법을 규정하는 수단을 반드시 제공해야 한다. 그리고 구성요소 서브시스템 간의 인터페이스에서 잠재적인 오류를 검출함으로써 시스템의 신뢰성을 증가시킬 수 있다. 

## Security

**보안**은 외부 또는 내부의 공격을 방어하는 기법이다. 보안을 위해 운영체제는 공격의 일부를 막는 기능을 직접하거나 다른 정책이나 부가적인 응용에 맡기는 방법을 사용한다. 

# Virtulization

**가상화**는 단일 컴퓨터의 하드웨어를 여러 가지 실행 환경으로 추상화하여 개별 환경이 자신만의 컴퓨터에서 실행되고 있다는 환상을 만드는 기술이다. 이러한 환경은 동시에 실행되고 서로 상호작용할 수 있는 다른 개별 운영체제로 볼 수 있다. 

**가상 머신**의 사용자는 단일 운영체제에서 동시에 실행되는 다양한 프로세스가 다른 프로세스로 전환할 수 있는 것과 동일한 방식으로 다양한 운영체제 사이를 전환할 수 있다. 

가상화는 운영체제가 다른 운영체제 내에서 하나의 응용 프로그램처럼 수행될 수 있게 한다. 넓게 말하면 가상화 소프트웨어는 에뮬레이션을 포함하는 클래스의 구성원이다. **에뮬레이션**은 소프트웨어로 컴퓨터 하드웨어를 시뮬레이션 하는 것을 의미한다. 이는 일반적으로 소스 CPU 유형이 대상 CPU 유형과 다른 경우에 사용된다. 예를 들어 Apple사가 CPU를 IBM Power CPU에서 Intel x86 CPU로 전환했을 때, 'Rosetta'라는 에뮬레이션 설비를 포함하여 IBM CPU용 응용 프로그램을 Intel CPU에서 수행할 수 있게 만들었다. 

그리고 가상화는 다수 사용자가 작업을 병행 수행하기 위한 방법으로도 사용한다. IBM에서는 다수의 가상기계를 수행함으로써 많은 사용자들이 단일 사용자를 위해 설계된 시스템에서 작업을 수행할 수 있게 만들었다. 그리고 VMware과 Windows에서 수행되는 응용의 형태로 새로운 가상화 기술을 만들었다. 이 응용은 **게스트**라고 불리는 하나 이상의 운영체제 복사본들을 수행한다. 이를 관리하는 운영체제는 Windows는 **호스트**, VMware은 **VMM(가상 머신 관리자)** 이다. 이러한 관리 운영체제는 게스트 운영체제를 수행하고 그들의 자원 이용을 관리해서 각 게스트를 서로로부터 보호한다.

[1.8 분산 시스템](# Distributed Systems)

[1.9 커널 자료구조](# Kernel Data Structures)
[1.9.1 리스트, 스택, 큐](## Lists Stacks Queues)
[1.9.2 트리](## Trees)
[1.9.3 해시 함수와 맵](## Hash-Functions and Maps)
[1.9.4 비트맵](## Bitmaps)

[1.10 컴퓨팅 환경](# Computing Environments)
[1.10.1 전통적인 컴퓨팅](## Tranditional Computing)
[1.10.2 모바일 컴퓨팅](## Mobile Computing)
[1.10.3 클라이언트-서버 컴퓨팅](## Client-Server Computing)
[1.10.4 피어 간 컴퓨팅](## Peer-to-Peer Computing)
[1.10.5 클라우딩 컴퓨팅](## Cloud Computing)
[1.10.6 실시간 내장형 시스템](## Real-time Embedded Systems)

[1.11 무료 및 공개 오픈 운영체제](# free-and-opensource-operating-systems)
[1.11.1 역사](## history)
[1.11.2 무료 운영체제](## free-operation-systems)
[1.11.3 GNU/Linux](## gnu-linux)
[1.11.4 BSD Unix](## bsd-unix)
[1.11.5 Solaris](## solaris)
[1.11.6 학습 도구로서 오픈 소스 시스템](## open-source-systems-as- learning-tools)




