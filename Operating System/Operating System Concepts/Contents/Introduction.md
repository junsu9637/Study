# 서론

> \- 컴퓨터 시스템의 일반적인 구성과 인터럽트의 역할         
  \- 현대 다중 처리기 컴퓨터 시스템의 구성요소             
  \- 사용자 모드에서 커널 모드로의 전환             
  \- 다양한 컴퓨팅 환경에서 운영체제의 사용 방식              
  \- 공개 소스 운영체제의 예             


**Operating System(운영체제)**
하드웨어를 관리하는 소프트웨어    
응용 프로그램을 위한 기반을 제공하며 컴퓨터 사용자와 컴퓨터 하드웨어 사이의 중재자 역할 수행

운영체제의 역할을 학습하기 위해서는 먼저 컴퓨터 하드웨어의 구성과 구조를 이해하는 것이 중요하다.

운영체제는 덩치가 크고 복잡하기 때문에 부분별로 생성 되어야 하고, 이 하나의 부분은 전체 시스템 윤곽에 잘 맞는 일부여야 한다.



# 차례
[1.1 운영체제가 할 일](#what-operating-system-do)          
[1.1.1 사용자 관점](#user-view)            
[1.1.2 시스템 관점](#system-view)                 
[1.1.3 운영체제의 정의](#operating-system-definitions)              

[1.2 컴퓨터 시스템의 구성](#computer-system-organization)             
[1.2.1 인터럽트](#interrupts)            
[1.2.2 저장장치 구조](#storage-structure)             
[1.2.3 입출력 구조](#io-structure)              

[1.3 컴퓨터 시스템의 구조](#computer-system-architecture)             
[1.3.1 단일 처리기 시스템](#single-processor-systems)           
[1.3.2 다중 처리기 시스템](#multiprocessor-systems)             
[1.3.3 클러스터형 시스템](#clustered-systems)             

[1.4 운영체제의 작동](#Operating-System-Operations)             
[1.4.1 다중 프로그래밍과 다중 태스킹](#multiprogramming-and-multitasking)              
[1.4.2 이중모드와 다중모드 운용](#dualmode-and-multimode-operation)             
[1.4.3 타이머](#timer)             
           
[1.5 자원 관리](#Resource Management)

[1.6 보안과 보안](#Security and Protection)

[1.7 가상화](#Virtulization)

[1.8 분산 시스템](#Distributed-Systems)

[1.9 커널 자료구조](#Kernel_Data-Structures)

[1.10 계산 환경](#Computing Environments)

[1.11 무료 및 공개 소스 운영체제](#Free-and-OpenSource-Operating-Systems)



# What Operating System Do

운영체제가 수행하는 역할을 알아보기 전에 컴퓨터 시스템에 대한 논의부터 진행해야 한다. 컴퓨터 시스템은 4가지 구성요소인 **하드웨어, 운영체제, 응용 프로그램, 사용자**로 구분할 수 있다.

**하드웨어**            
> CPU(중앙 처리 장치), 메모리, I/O(입출력) 장치로 구성                        
  기본 계산용 자원 제공          

**응용 프로그램**                    
> 사용자의 계산 문제를 해결하기 위해 자원이 어떻게 사용될지 정의           
  위드 프로세서, 스프레드시트, 컴파일러, 웹 브라우저 등        

**운영체제**           
> 다양한 사용자를 위해 다양한 응용 프로그램 간의 하드웨어 사용을 제어 및 조정    
  자체로는 유용한 작업을 수행할 수 없음
  다른 프로그램이 유용한 작업을 할 수 있는 **환경** 제공
  
운영체제의 역할을 완전히 이해하기 위해서는 사용자와 시스템의 두 관점에서 살펴봐야 한다.

## User View

컴퓨터에 대한 사용자의 관점은 사용되는 인터페이스에 따라 달라진다.

*모니터, 키보드, 마우스로 구성된 PC*
> 한 사용자가 자원을 독점하도록 설계        
  운영체제 : 사용의 용이성을 위해 설계되고, 자원의 이용은 신경쓰지 않는다.
  
*가전제품 내 내장형 컴퓨터*
> 운영체제 : 사용자의 개입 없이 작동하도록 설계

## System View

컴퓨터의 관점에서 운영체제는 하드웨어와 가장 밀접하게 연관된 프로그램이다.

**운영체제**
> **Resource Allocator(자원 할당자)**         
  제 해결을 위해 요구되는 여러 자원(CPU 시간, 메모리 공간, 저장장치 공간 등)을 할당할지 결정       
  **Control Program(제어 프로그램)**         
  컴퓨터의 부적절한 사용을 방지하기 위해 사용자 프로그램의 수행을 저지

## Operating System Definitions

컴퓨터의 설계와 용도에 따라 수행해야할 역할과 기능이 달라지기 때문에 운영체제가 많은 역할과 기능을 수행해야 한다.

초기 컴퓨터       
목적 : 군사용, 정부 업무 등의 고정 목적 시스템          
특징 : 범용의 다기능 대형 컴퓨터로 발전 및 운영체제 등장

1960년대 무어의 법칙이 집적회로의 트랜지스터 수가 18개월마다 배로 늘어날 것으로 예측           
컴퓨터는 기능이 확대되고 크기가 작아지고, 용도가 다양화 되면서 다양한 운영체제 등장

**컴퓨터 시스템**의 기본 목표는 프로그램을 실행하고 사용자 문제를 쉽게 해결할 수 있게 만드는 것이다. 컴퓨터 **하드웨어**는 이러한 목표를 가지고 구성되지만 하드웨어 만으로는 사용하기가 쉽지 않아 **응용 프로그램**이 개발된다. 이러한 프로그램에는 특정 공통 작업이 필요하면서 자원을 제어하고 할당하는 **운영체제**가 개발된다.

따라서 운영체제는 적합한 정의나 운영체제에 포함되는 요소의 보편적인 정의가 없다. 운영체제는 단지 유용한 컴퓨팅 시스템을 만들기 위한 합리적인 방법을 제공하는 방식이다.

운영체제는 커널과 시스템 프로그램으로 구성된다. 종종 미들웨어를 포함하는 경우도 존재한다.
> 커널 : 컴퓨터에서 항상 실행되는 프로그램
  미들웨어 : 응요 프로그램 개발자에게 추가 서비스를 제공하는 소프트웨어 프레임워크
  
```markdown
운영체제
커널 + 미들웨어 프레임워크 + 시스템 프로그램
(항상 실행) + (응용 프로그램 개발 용이) + (시스템 관리)
```

# computer-system-organization

현대의 범용 컴퓨터 시스템은 하나 이상의 CPU와 구성요소, 공유 메모리 사이의 엑세스를 제공하는 공통 **버스**를 통해 연결된 여러 장치 컨트롤러로 구성된다. 각 장치 컨트롤러는 특정 유형의 장치를 담당하지만, 컨트롤러에 따라 2개 이상의 장치가 연결될 수 있다. 

**장치 컨트롤러**        
> 일부 로컬 버퍼 저장소와 특수 목적 레지스터 집합 유지, 관리         
  제어하는 주변 장치와 로컬 버퍼 저장소간 데이터 이동    

일반적으로 운영체제에는 각 장치 컨트롤러마다 장치 드라이버가 있다.

**장치 드라이버**
> 장치 컨트롤러의 작동을 잘 알고, 운영체제와 장치 사이 인터페이스 역할

CPU와 장치 컨트롤러는 메모리에 대한 엑세스를 동기화한다. 이러한 시스템 작동방식의 3가지 주요 측면에 대해 살펴보자

## interrupts

일반적인 입출력을 수행하는 컴퓨터 작업은 아래와 같이 실행된다.
```markdown
1. 장치 드라이버는 장치 컨트롤러의 적절한 레지스터 값 적재
2. 장치 컨트롤러는 레지스터 내용을 검사해 수행할 작업 결정
3. 컨트롤러는 장치에서 로컬 버퍼로 데이터 전송 시작
4. 데이터 전송이 완료되면 장치 컨트롤러는 장치 드라이버에게 작업 완료 알림
5. 장치 드라이버는 제어권을 넘기거나 상태 정보를 반환
```

이때 컨트롤러는 **인터럽트**를 통해 장치 드라이버에게 작업을 완료했다는 사실을 알린다. 

### Overview

하드웨어는 어느 순간이든 시스템 버스를 통해 CPU의 신호를 보내 인터럽트를 발생시킬 수 있다. 따라서 인터럽트는 운영체제와 하드웨어의 상호 작용 방식의 핵심 부분이다.

CPU 인터럽트 발생
```markdown
1. CPU가 하던 작업을 중단하고 고정된 위치로 실행을 옮김
2. 인터럽트 서비스 루틴 시작(고정된 위치에 인터럽트 서비스 루틴 저장되어 있음)
3. 인터럽트 서비스 루틴 종료 시, DPU는 인터럽트 되었던 연산 재개
```

인터럽트는 컴퓨터 구조의 중요한 부분이기 때문에 각 컴퓨터 설계는 자신의 인터럽트 메커니즘을 가지고 있으며 몇 가지 기능은 공통으로 적절한 서비스 루틴으로 적절한 제어를 전달한다. 

인터럽트 루틴은 인터럽트 고유의 핸들러를 호출한다. 인터럽트는 매우 빈번하게 발생하기 때문에 이를 빠르게 처리되어야 한다. 필요한 속도를 위해 인터럽트 루틴에 대한 포인터들의 테이블을 대신 이용할 수 있어야 한다.

일반적으로 포인터들의 테이블은 하위 메모리에 저장된다. 이 위치에는 여러 장치에 대한 인터럽트 서비스 루틴의 주소가 들어 있다. 인터럽트가 요청되면, 인터럽트를 유발한 장치를 위한 인터럽트 서비스 루틴을 제공하기 위해 인터럽트 벡터(주소 배열)가 인터럽트 요청과 함께 주어진 고유 장치 번호로 색인된다. 

인터럽트 구조는 인터럽트 된 모든 정보를 저장해야 인터럽트를 처리한 후 이 정보를 복원할 수 있다. 

```markdown
1. 인터럽트 루틴이 처리기의 상태를 변경해야 한다면, 인터럽트 루틴은 현재 상태를 저장
2. 인터럽트를 서비스한 후 저장되어 있던 복귀 주소를 프로그램 카운터에 적재
3. 인터럽트에 의해 중단 되었던 연산 다시 실행
```

### Implementation

기본 인터럽트 메커니즘의 작동
```markdown
1. CPU 하드웨어는 **인터럽트 요청 라인**으로 명령어의 실행 완료를 감지
2. 실행 완료를 감지하면 인터럽트 번호를 읽고 이 번호를 인터럽트 벡터의 인덱스로 사용
3. 인덱스에 따라 **인터럽트 핸들러 루틴**으로 점프
4. 해당 인텍스와 관련된 주소에서 실행 시작
5. 인터럽트 처리기는 작업 중 변경될 상태를 저장, 인터럽트 원인 확인, 필요한 처리, 상태 복원 수행
6. **return_from-interrupt** 명령어 실행
7. CPU를 인터럽트 발생 전 실행 상태로 되돌린다.
7.1. 장치 컨트롤러가 인터럽트 요청 라인에 신호를 선언하여 인터럽트 **발생(raise)**
7.2. CPU가 인터럽트를 **포착(catch)** 하여 인터럽트 핸들러로 **디스패치(dispatch)**
7.3 핸들러는 장치를 서비스하여 인터럽트 **지움(clear)**
```

**인터럽트 컨트롤러 하드웨어**는 보다 정교한 인터럽트 처리 기능을 제공한다
> \-중요한 처리 중 인터럽트 연기          
  \-장치의 적절한 인터럽트 핸들러로 효율적으로 디스패치               
  \-우선순위에 따라 인터럽트를 구별               
  \-긴급도로 대응할 수 있도록 다단계 인터럽트 구축            

대부분의 CPU에는 2개의 인터럽트 요청 라인이 있다.
> **마스킹 불가능 인터럽트** : 메모리 오류와 같은 이벤트를 위해 예약하기 위해 사용
  **바스킹 가능 인터럽트** : 장치 컨트롤러가 서비스를 요청하기 위해 사용

벡터 방식 인터럽트 기법의 목적은 서비스가 필요한 장치를 결정하기 위해 하나의 인터럽트 핸들러가 가능한 모든 인터럽트 소스를 검색할 필요를 줄이는 것이다. 그러나 실제 컴퓨터에는 인터럽트 벡터의 주소 개수보다 많은 장치(인터럽트 처리기)가 있다. 따라서 **인터럽트 체인**을 사용한다.

**인터럽트 체인**
큰 크기의 인터럽트 테이블의 오버헤드와 하나의 인터럽트 핸들러로 디스패치 하는 비효율성의 절충안
```markdown
1. 인터럽트 벡터의 각 원소는 인터럽트 핸들러 리스트의 헤드를 가리킨다.
2. 인터럽트가 발생하면 요청을 처리할 수 있는 핸들러가 발견될 때까지 상응하는 리스트의 핸들러가 하나씩 호출
```

인터럽트 기법은 인터럽트 **우선순위 레벨**을 구현한다. 이러한 레벨을 통해 CPU는 모든 인터럽트를 마스킹하지 않고도 우선순위가 낮은 인터럽트 처리를 연기할 수 있고, 우선순위가 높은 인터럽트를 선점할 수 있다. 

```markdown
인터럽트        
최신 운엥체제에서 비동기 이벤트를 처리하기 위해 사용            
장치 컨트롤러 및 하드웨어 오류로 인해 발생             
가장 긴급한 작업을 먼저 처리하기 위해 우선순위 시스템 사용             
시스템 성능을 좋게 하려면 효율적인 인터럽트 처리가 필요           
```

## Storage Structure

CPU는 메모리에서만 명령을 적재할 수 있으므로 CPU가 실행하려면 먼저 메모리에 프로그램을 적재해야한다. 범용 컴퓨터는 프로그램 대부분을 **메인 메모리(RAM)** 라고 불리는 재기록 가능한 메모리에서 가져온다. 

RAM은 휘발성이기 때문에 컴퓨터 전원을 켤 때 실행되어 운영체제를 적재시키는 **부트스트랩 프로그램**을 유지하는 용도로는 사용할 수 없다. 따라서 컴퓨터는 전기적으로 소거 가능한 프로그램 읽기 전용 메모리(EEPROM) 및 기타 **펌웨어**(쓰기 작업이 자주 발생하지 않고 비휘발성인 저장장치)를 사용한다. 

모든 형태의 메모리는 바이트의 배열을 제공한다. 각 바이트는 자신의 주소를 가지고 있고, 상호 작용은 특정 메모리 주소들에 대한 **load(적재)**, **store(저장)** 명령어를 통해 이루어진다. 그리고 CPU는 프로그램 카운터에 저장된 위치로부터 실행하기 위해 메인 메모리로 명령을 자동으로 적재한다.
> Load : Main Memory -> CPU 내부 레지스터로 한 바이트 혹은 한 워드를 옮김
  Store : CPU 내부 레지스터 -> Main Memory로 한 바이트 혹은 한 워드를 옮김
  
**폰 노이만 구조 시스템**에서 실행되는 명령-실행 사이클은 아래와 같다
```markdown
1. 메모리로부터 명령어를 인출
2. 명령을 Instruction Register(명령어 레지스터)에 저장
3. 명령 해독
4. 메모리로부터 피연산자를 인출
5. 피연산자를 내부 레지스터에 저장
6. 결과를 메모리에 저장
```

이 과정에서 메모리는 메모리 주소만을 인식한다는 것에 주목해야한다. 메모리는 주소*[Instruction Counter(명령 카운터), (Indexing)색인, (Indirection Addresses)간접주소, (Literal Addresses)리터럴 주소]* 가 어떻게 생성되었는지 알지 못하고, 명령인지 데이터인지 알지 못한다. 따라서 우리는 메모리 주소가 프로그램에 의해 어떻게 생성되었는지 무시할 수 있고, 메모리 주소에만 집중하면 된다.

메인메모리에 프로그램이 영구적으로 존재하면 좋겠지만, 메인 메모리의 저장 용량이 부족하고, 비휘발성이기 때문에 전원 공급이 중단되면 데이터가 소멸되기 때문에 영구저장이 불가능한다. 

따라서 대부분의 컴퓨터 시스템은 메인 메모리의 확장으로 **보조기억장치**를 사용한다. 보조기억장치는 대량의 데이터를 영구히 보존할 수 있다. 대표적으로 하드 디스크 드라이버(HDD), 비휘발성 메모리(NVM)이 있다. 대부분의 프로그램은 메모리에 적재될 때까지 보조기억장치에 저장된다. 보조기억장치는 메인 메모리보다 휠씬 느리기 때문에 2차 저장장치의 올바른 관리가 중요하다.


**저장장치 계층 구조**
```markdown
1차 저장장치 : 휘발성 저장장치
(레지스터 > 캐시 > 메인 메모리)
2차 저장장치 : 비휘발성 저장장치
(NVM > HDD)
3차 저장장치 : 특수 목적 저장장치
(광학 디스크 > 자기 테이프)
```

위 계층 구조에서 메모리가 작고 빠를수록 CPU에 가깝다. 최상위 4단계 메모리(레지스터~NVM)는 반도체 기반 전자회로로 구성된 **반도체 메모리**를 사용하여 구성된다. 보통 휘발성 저장장치를 메모리라고 표현하고, 비휘발성 저장장치를 NVS라고 표현한다. 대부분의 경우 NVS는 보조기억장치를 가리키는데 NVS는 기계적과 전기적으로 분류한다.

> **기계적 NVS**        
  HDD, 광 디스크, 자기 테이프 등            
  **전기적 NVS(=NVM)**            
  SSD, 플래시 메모리, FRAM, NRAM 등           

## Io structure

운영체제에서 시스템의 안정성과 성능이 가장 중요한 부분이다. 이러한 이유를 운영체제 코드의 상당 부분은 I/O 관리에 할애한다. 

컴퓨터 시스템은 범용 버스를 통해 데이터를 교환하는 여러 장치로 구성된다. 인터럽트 구동 I/O의 경우 소량의 데이터를 이동하는 데는 좋지만 NVS I/O와 같은 대량 데이터 이동에 사용될 때 높은 오버헤드를 유발할 수 있다. 이러한 문제를 해결하기 위해 **직접 메모리 엑세스(DMA)** 가 사용된다. 이 방법의 진행 과정은 다음과 같다.

```markdown
1. 장치에 대한 버퍼, 포인터, 입출력 카운터 설정
2. 장치 제어기는 CPU의 개입 없이 메모리로부터 자신의 버퍼 장치로 또는 버퍼로부터 메모리로 데이터 블록 전체 전송
3. 블록 전송이 완료될 때마다 인터럽트 발생
4. 장치 제어기가 전송 작업을 수행하고 있는 동안 CPU는 다른 작업 수행
```

몇몇 고가의 시스템은 버스 대신 스위치 구조를 사용해서 공유 버스를 사용하기 위한 사이클 경쟁을 없애고, 다수의 구성요소가 다른 구성요소들과 동시에 통신하는 것이 가능하다. 이 경우 DMA의 사용 효과가 증가한다. 

# Computer-System Architecture

컴퓨터 시스템은 사용된 범용 프로세서의 수에 따라 분류 가능한 다양한 방식으로 구성된다.

## Single-Processor Systems

단일 프로세서 시스템은 단일 코어를 가진 하나의 CPU를 포함하는 단일 프로세스를 사용한다. 여기서 코어는 명령을 실행하고 로컬로 데이터를 저장하기 위한 레지스터를 표함하는 구성요소다. 코어를 가진 하나의 메인 CPU는 프로세스의 명령어를 포함하여 범용 명령어 세트를 실행할 수 있다. 

이 시스템에는 다른 특수 목적 프로세서도 포함되는데 이 모든 전용 프로세서들은 제한된 명령어 집합을 실행하고 사용자 프로세스를 실행하지 않는다. 운영체제는 이 프로세스들이 수행할 다음 작업에 대한 정보를 보내고 프로세서 상태를 감시한다. 운영체제는 이 프로세서들과 통신할 수 없으며 이 프로세서들은 독립적으로 자신의 작업을 처리한다. 

## Multiprocessor Systems

### 단일 코어 시스템

다중 프로세스 시스템은 각각 단일 코어 CPU가 있는 2개 이상의 프로세서가 있다. 프로세서는 컴퓨터 버스, 클록, 메모리, 주변장치를 공유하면서 정보 처리량을 증가시킨다. 그러나 여러 프로세서가 하나의 작업을 수행할 때, 모든 프로세서가 일정하게 작동하는 것이 아니기 때문에 N 프로세서의 속도 향상 비율은 N 배가 아니다. 

가장 일반적인 다중 프로세서 시스템은 각 CPU 프로세서가 운영체제 기능과 사용자 프로세스를 포함한 모든 작업을 수행하는 **SMP(Symmetric MultiProcessing)** 를 사용한다. 이 모델은 각 CPU 처리기에는 개별 캐시, 자체 레지스터가 있지만 모든 프로세서는 시스템 버스를 통해 물리 메모리를 공유한다. 

이 모델의 장점은 많은 프로세스를 동시에 실행할 수 있다는 것이다. 그러나 CPU가 독립적이기 때문에 특정 하나가 과부화에 걸려 비효율적일 수 있다. 이러한 문제는 프로세서가 특정 자료구조를 공유하거나 자원을 다양한 프로세서간 동적 공유를 수행한다면 해결할 수 있다. 

### 다중 코어 시스템

다중 프로세서의 정의는 시간이 지남에 따라 발전해 왔고, 현재는 여러 개의 컴퓨팅 코어가 단일 칩에 상주하는 **다중 코어 시스템**을 포함한다. 칩 내 통신이 칩 간 통신보다 빠르기 때문에 다중 코어 시스템은 단일 코어 시스템보다 속도가 빠르고, 전력 소모가 적다.

다중 코어 시스템의 설계에서 각 코어에는 자체 레지스터와 공유 레지스터로 구성된다. 자체 레지스터는 L1 캐시 혹은 자체 로컬 캐시라고 부른다. 공유 레지스터는 L2 캐시라고 부르며 코어들끼리 데이터를 공유한다. 대부분의 아키텍쳐는 L1 캐시와 L2 캐시를 결합한 방식을 사용한다. 

### NUMA

CPU의 개수를 추가하면 컴퓨팅 성능이 향상되지만, CPU를 너무 많이 추가하면 시스템 버스에 대한 병목 현상과 같은 문제가 발생한다. 이러한 문제를 해결하기 위해서는 CPU에 작고 빠른 로컬 버스를 통해 엑세스 되는 자체 로컬 메모리를 제공하는 것이다. 이렇게 모든 CPU가 **공유 시스템**으로 연결되어 하나의 물리 주소 공간을 공유하는 방법을 **NUMA(Non-Uniform Memory Access)** 라고 한다. 이 시스템은 CPU가 로컬 메모리에 엑세스 할 때 속도가 빠르고, 시스템 상호 연결에 대한 경합이 없다. 따라서 NUMA 시스템은 많은 프로세서가 추가될수록 더 효과적으로 확장할 수 있다.

하지만 CPU가 시스템 상호 연결을 통해 원격 메모리에 엑세스해야 할 때 지연 시간이 증가하는 문제가 있다. 즉 CPU<sub>0</sub>가 자체 로컬 메모리에 엑세스 하는 것보다 CPU<sub>3</sub>의 로컬 메모리에 엑세스하는 속도가 월등하게 느리다. 이런 문제는 CPU 스케줄링, 메모리 관리를 통해 최소화할 수 있다. 

### 블레이드 서버

**블레이드 서버**는 다수의 프로세서 보드, 입출력 보드, 네트워킹 보드를 하나의 **Chassis** 안에 저장되는 형태로 구성된다. 이 시스템은 각 보드들이 독립적인 운영체제를 포함하고 있다. 

## Clustered Systems

클러스터형 시스템은 둘 이상의 독자적 시스템 또는 노드들을 연결하여 구성한다. 여기서 노드는 다중 코어 시스템을 의미한다. **클러스터형**의 정의는 분명하지 않다. 일반적으로 받아들여지는 정의는 클러스터 컴퓨터는 저장장치를 공유하고 근거리 통신망이나 고속 상호 연결망을 통해 연결다는 것이다. 한 클러스터가 네트워크로 연결된 다수의 컴퓨터 시스템으로 구성되므로 클러스터는 **고성능 계산 환경**을 제공할 수 있다.

이를 위해서는 응용 프로그램이 클러스터를 이용할 수 있게 작성되야한다. 이는 **병렬화**라는 기법으로 프로그램을 클러스터의 각 컴퓨터에서 수행되는 분리된 요소로 나누는 작업을 수행한다. 이를 통해 응용 프로그램은 클러스터의 각 계산 노드가 문제의 일부를 해결한 후 모든 노드의 결과를 결합하여 최종 결과를 산출한다.

클러스터링은 **높은 가용성**을 제공하기 위해 사용된다. 즉 클러스터 내 특정 컴퓨터 시스템이 고장 나더라도 서비스는 계속 제공된다. 이러한 높은 가용성은 시스템에 중복 기능을 추가함으로써 얻어진다. 
```markdown
1. 클러스터 소프트웨어 중 한 층이 클러스터 노드에서 실행된다.
2. 각 노드는 하나 이상의 노드들을 감시한다.
3. 감시받던 노드가 고장나면 그 노드의 저장장치 소유권을 넘겨받는다.
4. 고장난 노드에서 실행 중이던 응용 프로그램을 다시 시작한다.
```

이렇게 시스템 내부의 단일 구성요소에 오류가 발생하여도 계속 작동할 수 있으므로 **결함허용 시스템**이라고도 한다. 

### 비대칭형 클러스터링

다른 컴퓨터들이 응용 프로그램을 실행하는 동안 한 컴퓨터는 **긴급 대기 모드(Hot-Standby)** 상태를 유지한다. 이 긴급 대기 모드는 활성 서버들을 감시하는 작업만 수행한다. 서버가 고장나면 긴급 대기 모드의 호스트가 활성 서버가 된다.

### 대칭형 클러스터링

둘 이상의 호스트들이 응용 프로그램을 실행하고 서로를 감시한다. 가용한 하드웨어를 모두 사용하기 때문에 보다 효율적이다. 대칭형 구성이 효율적으로 동작하기 위해서는 하나 이상의 응용 프로그램들이 실행 가능해야 한다. 

### 병렬 + WAN 클러스터링

여러 호스트가 공유 저장장치상의 동일한 데이터에 접근할 수 있게 구성한다. 운영체제의 대부분이 여러 호스트에 의한 동시 접근을 지원하지 않기 때문에 병렬 클러스터는 특수 소프트웨어 버전을 사용한다. 예를 들어 Oracle Real Application Cluster이 있다.
```markdown
1. 각 코어는 데이터베이스 내의 모든 데이터에 대한 완전한 접근을 한다.
2. 시스템은 접근 간의 충돌이 발생하지 않게 접근 제어와 잠금 기법을 제공한다. 
(이러한 기능은 DLM(분산 잠금 관리자)라고 부르며 클러스터 소프트웨어에 포함된다.)
```

### 병렬 + SAN 클러스터링

SAN(스토리지 전용 네트워크)를 사용하여 한 클러스터 내에 수천 개의 노드를 지원한다. 응용 프로그램과 데이터가 SAN에 저장된다면 클러스터 소프트웨어는 SAN에 연결된 임의의 호스트에게 배정할 수 있다. 또한 수십 개의 호스트가 동일한 데이터베이스를 공유할 수 있기 때문에 성능과 신뢰도를 크게 증가시킨다. 

# Operating-System-Operations
## multiprogramming-and-multitasking
## dualmode-and-multimode-operation
## timer
