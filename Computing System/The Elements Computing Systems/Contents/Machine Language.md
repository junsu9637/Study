[4. 기계어](#machine-language)    

[4.1 배경](#background)         
[4.1.1 기계](#machine)        
[4.1.2 언어](#language)         
[4.1.3 명령](#command)         

[4.2 명세](#specification)      
[4.2.1 개요](#outline)      
[4.2.2 A-명령어](#a-command)                   
[4.2.3 C-명령어](#c-command)          
[4.2.4 기호](#symbol)           
[4.2.5 입출력 조작](#io-manipulation)            
[4.2.6 구문 규칙과 파일 형식](#syntax-rules-and-file-types)                

# Machine Language

컴퓨터는 어떤 하드웨어 플랫폼을 저수준 칩들로 어떻게 구성했는지를 **구성적**으로 설명할 수 있다. 그리고 기계어의 함수들을 정의하고 사용법을 보여주는 방식으로 **추상적**으로 설명할 수 있다. 기계어 프로그램을 통해 하드웨어가 왜 이렇게 설계되었는지 이해하는데 도움이 된다.

기계어는 기계 수준의 명령어들로 이루어진 저수준 프로그램을 코딩할 수 있도록 미리 정의된 규칙으로 해당 하드웨어 플랫폼에서 직접적으로 명령을 실행하거나 하드웨어를 완전히 제어하는 것을 주요 목표로 삼는다. 

기계어는 전체 컴퓨터 시스템에서 가장 기본이 되는 인터페이스로 하드웨어와 소프트웨어가 만나는 접점이다. 즉 기계어는 프로그래밍 도구인 동시에 하드웨어 플랫폼의 구성 요소가 된다. 

## Background

### Machine

**기계어**는 프로세서와 레지스터들을 이용해서 메모리르 조작할 수 있도록 미리 정의된 규칙이라고 볼 수 있다.

#### 메모리

메모리는 컴퓨터에서 데이터와 명령어를 저장하는 하드웨어 장치들을 통칭하는 용어다. *'단어'* 나 *'위치'* 라고 불리는 정해진 폭의 셀들이 연속적으로 배열되어 각각에 유일한 *'주소'* 가 있는 구조다. 따라서 개별 단어는 주소를 통해 특징된다. 이러한 주소는 `Memory[address], RAM[address], M[address]` 로 표현한다.

#### 프로세서 

CPU 혹은 중앙 처리 장치라고 불리는 특정한 기초 연산들을 수행하는 장치다. 기초 연산은 산술 및 논리 연산, 메모리 접근 연산, 제어 연산이 포함된다. 이 연산의 피연산자는 선택된 메모리 위치와 레지스터에 있는 2진 값이다. 연산의 결과값은 선택된 메모리 주소나 레지스터에 저장된다.

#### 레지스터

레지스터는 프로세서 바로 엎에 위치해서, 프로세서가 명령어와 데이터를 빠르게 조작할 수 있도록 도와주는 로컬 고속 메모리의 역할을 수행한다. 

### Language

기계어 프로그램은 명령어들을 코드화 한 것으로 0101010101010101과 같이 표현된다. 이 명령의 뜻을 확인하려면 하드웨어 플랫폼의 명령 집합을 알아야 한다. 

기계어는 보통 **2진 코드**와 **연상기호**를 사용한다. 여기서 연상기호는 기호의 의미를 알기 쉽도록 힌트가 될 만한 이름으로 붙인 기호를 뜻한다. 예를 들어 2진 코드 1010을 ADD, 0101 주소의 레지스터를 R1, 1111 주소의 레지스터를 R2라고 명명한다면 101001011111을 ADD, R1, R2로 표기할 수 있다.

이 표기법을 한 단계 더 추상화하면, 이 기호들을 **읽기**만 하는 단계를 넘어 기호를 작성해서 **프로그램을 작성**할 수 있다. 이러한 방법을 **Assembly Language(어셈블리 언어)** 라고 부르고, 어셈블리를 2진 코드로 변환하는 프로그램을 **Assembler(어셈블러)** 라고 부른다. 어셈블러가 작동하는 과정은 다음과 같다.
```markdown
1. 기호 명령어들을 텍스트 처리 프로그램으로 분석
2. 필드(연상기호, 피연산자)를 식별
3. 각 필드를 동일한 의미의 2진 표현으로 변환
4. 전체 코드를 2진 기계 명령어로 번역
```

### Command

#### 산술 및 논리 연산

모든 컴퓨터는 기초 산술 연산 외에 Bit-Wise Negation(비트 반전), Bit Shifting(비트 이동) 등의 기본적인 불 연산도 가능해야 한다.

#### 메모리 접근

메모리 접근은 다음과 같이 두 가지로 분류된다.
```markdown
1. 산술 및 논리 명령은 레지스터 외 특정 메모리 주소에 접근 가능
2. 레지스터와 메모리 사이 데이터 이동 (load, store)
```

메모리 접근 명령은 메모리 주소를 특정하는 방법인 **주소 지정 모드**가 다양하게 존재한다.

##### Direct Addressing

**직접 주소 지정 방식**은 메모리에 접근하는 가장 일반적인 방법이다. 다음과 같이 그 주소를 나타내는 기호를 활용하는 방식을 사용한다.
```
LOAD R1, 67 // R1 <- Memory[67]
```

##### Immediate Addressing

**즉시 주소 지정 방식**은 명령어 코드에 있는 상수를 불러오는데 사용한다. 즉 명령어에 있는 숫자 필드를 주소로 취급하는 대신에 그 값 자체를 다음과 같이 레지스터로 로드한다.
```
LOAD R1, 67 // R1 <- 67
```

##### Indirect Addressing

**간접 주소 지정 방식**은 명령어에 메모리 주소가 하드코딩 되지 않는 대신 필요한 주소 값을 저장하고 있는 메모리 위치를 참조하는 명령어를 사용한다. 이는 하드웨어 적으로 다음과 같은 과정을 수행한다.
```markdown
0. foo : 배열변수, x,j : 정수 변수
1. 고수준 명령 x = foo[j] 실행
2. 고수준 프로그램에서 배열 foo를 정의하고 초기화
3. 컴파일러가 배열 데이터를 저장할 메모리 세그먼트 할당
4. foo 기호가 이 세그먼트의 시작 주소를 가리키도록 설정
5. foo 값에 j를 더한다. 
```
이러한 과정을 코드로 구현하면 다음과 같다.
```
ADD R1, foo, j // R1 <- foo + j
LOAD* R2, R1 // R2 <- Memory[R1]
STR R2, x // x <- R2
```

##### Flow of Control

프로그램은 종종 다른 위치로 **분기**해서 실행되기도 한다. 분기로는 다음과 같은 종류가 있다.
> **반복** : 루프의 시작으로 점프해서 돌아감        
  **조건 실행** : 불 조건이 거짓이면 'if else'절 다음의 위치로 점프       
  **서브루틴 호출** : 다른 코드 세그먼트의 첫 번째  멍령으로 점프       
  
모든 기계어는 이런 프로그래밍 구조를 지원하기 위해 다음과 같이 선택된 주소로 점프하는 기능을 포함하고 있다. 첫 번째 코드는 고수준 언어로 작성된 코드이고, 두 번째 코드는 첫 번째 코드를 저수준 언어로 변환한 코드이다.
```
while (R1 >= 0)
{
    code segment 1
}
code segment 2
```
```
beginWhile:
    JNG R1, endWhile // 만약 R1 < 0 면 endWhile로 이동
    (segment 1)
    JMP beginWhile // deginWhile로 이동
endWhile:

segment 2
```

JMP와 같은 **무조건 점프**명령에서는 가고자 하는 위치의 주소만 명시하면 된다. JNG와 같은 **조건 점프**명령은 불 조건을 어떤 식으로든 명시해 주어야 한다. 

## Specification

### Outline

앞으로 문서는 폰 노이만 플랫폼 기반의 CPU, 명령용과 데이터용으로 분리된 두 개의 메모리 모듈, 두 개의 메모리 매핑 I/O 장치(키보드, 모니터)로 구성된 16비트 장치를 기반으로 작성되었다.

#### 메모리 주소 공간

주소 공간을 **명령어 메모리**와 **데이터 메모리**로 분리한다. 폭이 16이기 때문에 메모리 주소 공간은 15비트가 된다.

CPU는 명령어 메모리에 존재하는 프로그램만 수행한다. 명령어 메모리는 읽기 전용으로 내부적인 방법으로는 프로그램을 로드할 수 없다. 예를 들어 콘솔 게임 칩과 같이 필요한 프로그램을 ROM 칩에 미리 새기는 방법이 있다. 이 방법은 ROM 칩을 새로 교체해야만 새로운 프로그램을 실행할 수 있다. 

이런 기능을 구현하기 위해 하드웨어 시뮬레이터에서는 이런 ROM 교체 방식을 시뮬레이션하기 위해, 텍스트 파일에 있는 기계어 프로그램을 명령어 메모리로 로드하는 기능을 제공한다. 

#### 레지스터

컴퓨팅 시스템에는 D와 A라 불리는 16비트 레지스터가 2개 있다. 이 레지스터들은 산술 명령이나 논리 명령으로 직접 조작된다.

> D : 데이터 값 저장 가능        
  A : 데이터 값, 데이터 메모리 주소, 명령어 메모리 주소 저장 가능
  
D는 데이터 값을 저장하는 용도로만 쓰이지만, A는 데이터 메모리, 명령어 메모리에 직접 접근하는 용도로도 사용 가능한다. 이러한 기능을 사용하기 위해 A-명령어라고 부르는 주소 명령어와 C-명령어라고 부르는 계산 명령어를 사용한다.  

### A-Command

**A-명령어**는 A레지스터에 값을 설정하는 데 사용된다. 설정하는 값이 16 비트라면, 15비트 값을 설정한다. 이는 A-명령어와 C-명령어를 구분하기 위해 LSB를 0으로 설정해야하기 때문이다. 

| 0 | value(15) |
|:-:|:-:|

A-명령어는 `@-value`라는 명령어로 표현된다. 예를 들어 `@5` 명령은 0000000000000101를 A 레지스터에 5를 저장하라는 뜻이다. 

A-명령어는 다음과 같은 기능을 한다.
```markdown
1. 상수 입력
2. A 레지스터에 데이터 주소 미리 입력(다음 C-명령어에서 해당 주소에 있는 값을 참조)
3. A 레지스터에 점프할 주소 미리 입력(다음 점프 C-명령어를 준비하는 용도)
```

### C-Command

**C-명령어**는 시스템 플랫폼에서 거의 모든 작업을 수행한다. C-명령어와 A-명령어를 구분하기 위해 LSB로부터 2개의 비트를 1로 설정한다. 따라서 설정하는 값이 16 비트라면, 13 비트 값을 설정한다. 

C-명령어는 **계산 필드(comp)** , **목적지 필드(dest)** , **점프 필드(jump)** 의 3 가지 필드가 존재한다.

| 1 1 1 | comp(7) | dest(3) | jump(3) |
|:-:|:-:|:-:|:-:|

```markdown
comp(7) : ALU가 할 연사 결정
dest(3) : 계산 된 값의 저장 위치 결정
jump(3) : 다음에 실행할 명령어 결정
```

#### 계산 필드

ALU는 A 및 Memory[A] 레지스터 상에서 미리 정해진 함수들을 계산한다. 계산할 함수는 comp 필드에서 정의된다. comp는 1개의 a 비트, 6개의 c 비트로 이루어져있다.

| a | c1 | c2 | c3 | c4 | c5 | c6 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|

#### 목적지 필드

comp 부분에서 계산된 값은 3비트 dest 부분이 가리키는 몇 가지 목적지에 저장된다. 첫 번째 d 비트는 계산된 값을 각각 A 레지스터에 저장할지를 결정하고, 두 번째 d 비트는 D 레지스터에 저장할지를 결정하며, 세 번째 d 비트는 계산된 값을 Memory[A]에 저장할지를 결정하는 코드다.
| d1 | d2 | d3 |
|:-:|:-:|:-:|

#### 점프 필드

컴퓨터가 다음에 수행할 일을 지시한다. 컴퓨터가 수행할 일은 다음과 같다.
```markdown
1. 프로그램에서 다음번 명령을 불러와서 실행하는 것
2. 프로그램 내 다른 곳에 위치한 명령을 불러와서 실행하는 것
```

점프 여부는 jump 필드의 3 개의 j 비트와 ALU 출력값에 달렸다. ALU의 출력값이 음수라면 첫 번째 j 비트에 의해 결정되고, ALU의 출력값이 0이라면 두 번째 j 비트에 의해 결정되며, ALU의 출력값이 양수라면 세 번째 j 비트에 의해 결정된다.

| j1 | j2 | j3 |
|:-:|:-:|:-:|

#### A 레지스터를 사용할 때 발생하는 충돌

프로그래머는 A 레지스터를 Memory[A]와 연계해 다음과 같은 작업을 수행할 수 있다.
```markdown
1. C-명령어의 데이터 메모리 위치를 선택
2. C-명령어의 명령어 메모리 위치를 선택
```

즉 두 경우가 충돌하는 현상이 발생할 수 있다. 이러한 현상을 막으려면 점프가 포함된 C-명령어가 Memory[A]를 참조하지 않도록 프로그램을 작성해야 한다. 

### Symbol

어셈블리 명령은 상수나 기호를 사용해서 메모리 주소를 참조할 수 있다. 어셈블리에서는 다음과 같은 3가지 방식(미리 정의된 기호, 레이블 기호, 변수 기호)으로 기호를 활용한다.

#### 미리 정의된 기호

RAM 내의 특정 주소들은 다음과 같이 미리 정의된 기호를 사용한다. 이 기호를 통해 모든 어셈블리 프로그램은 해당 주소를 참조할 수 있다.

##### 가상 레지스터

어셈블리 프로그램을 단순화하기 위해 기호 **R0~R15**는 RAM 주소 0~15를 가리키도록 정의한다.

##### 미리 정의된 포인터

**SP**, **LCL**, **ARG**, **THIS**, **THAT** 기호는 각각 RAM 주소 0~4를 참조하도록 정의된 기호다. 즉 가상 레지스터와 함께 사용할 수 있다. 예를 들어 주소 2는 R2나 ARG로도 참조 가능하다. 이러한 규칙은 가상 머신을 구현할 때 유용하게 사용된다.

##### I/O 포인터

**SCREEN**과 **KBD** 기호는 각각 RAM 주소 16384(0x4000)와 24576(0x6000)을 참조하도록 미리 정의된 기호다. 이 주소들은 모니터와 키보드의 메모리 매칭 시작 주소가 된다. 

#### 레이블 기호

goto 명령어의 목적지를 나타내는 레이블 기호는 사용자가 '(Xxx)'라는 **의사명령**으로 직접 선언한다. 이 명령은 다음에 실행할 명령을 담고 있는 명령어 메모리 주소를 기호 Xxx로 선언할 수 있다는 뜻이다. 레이블은 한 번 선언되면 어셈블리 프로그램 내 어디서든지 쓸 수 있다. 

#### 변수 기호

변수 기호는 다음과 같은 3가지 작업에 사용한다.

```markdown
1. 어셈블리 프로그램 내에서 미리 정의된 기호가 아닌지 확인
2. '(Xxx)' 명령으로 선언되지 않은 모든 사용자 정의 기호 Xxx를 변수로 취금
3. RAM 주소 16(0x0010)에서부터 차래대로 변수마다 메모리 주소 할당
```

### IO Manipulation

컴퓨팅 시스템은 모니터와 키보드에 연결될 수 있다. 두 장치는 메모리 맵을 통해 컴퓨터 플랫폼과 통신한다. 즉 메모리 세그먼트에 2진 값을 쓰면 그에 대응하는 모니터 위에 픽셀이 그려지는 방식이다. 그리고 키보드 입력은 해당 키에 대응하는 메모리 위치를 읽어 들이는 식으로 처리한다. 물리적 I/O 장치와 메모리 맵은 계속 갱신되는 루프를 통해 동기화된다.

#### 모니터

모니터에 표시되는 픽셀은 RAM 주소 16384(0x4000)부터 시작하는 메모리 맵에 대응한다. 모니터에서 각 행은 화면 맨 왼쪽 상단부터 시작하고, RAM 내에서는 32개의 연속된 16비트 단어로 표현된다. 즉 위에서 r번째 행, 왼쪽에서 c번째 열의 픽셀은 RAM[16384 + r\*32 + c/16]에 위치한 단어에 대응된다. 모니터에서 픽셀을 쓰거나 읽으려면 RAM 내 메모리 맵에서 해당 픽셀에 대응하는 비트를 읽거나 쓰면 된다. 

#### 키보드

키보드는 RAM 주소 24576(0x6000)부터 시작하는 메모리 맵에 대응한다. 키보드에서 키가 눌릴 때마다 눌린 키의 16비트 ASCII 코드가 RAM[24576]에 기록되는 식이다. 

### Syntax Rules and File Types

#### 2진 코드 파일

2진 코드 파일은 텍스트 라인들로 구성된다. 각 라인은 16개의 ASCII 문자 0과 1로 되어 있으며, 하나의 기계어 명령어를 부호화한 것이다. 컴퓨터의 명령어 메모리에 이 기계어 프로그램이 로드될 때, 파일의 n 번째 라인에 있는 2진 코드가 명령어 메모리의 주소 n에 저장되는 규칙을 따른다. 2진 코드 파일은 'hack' 확장자를 가지는 텍스트 파일에 저장된다(Prog.hack).

#### 어셈블리 언어 파일

어셈블리 언어 프로그램은 asm 확장자를 가지는 텍스트 파일에 저장된다(Prog.asm). 어셈블리 언어는 텍스트 라인으로 구성되며, 각 텍스트 라인은 명령어나 기호가 포함된다. 
