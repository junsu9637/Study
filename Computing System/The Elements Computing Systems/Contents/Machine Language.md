[4. 기계어](#machine-language)                  
[4.1 배경](#background)         
[4.1.1 기계](#machine)        
[4.1.2 언어](#language)         
[4.1.3 명령](#command)         

[4.2 명세](#specification)      
[4.2.1 개요](#outline)      
[4.2.2 A-명령어](#a-command)                   
[4.2.3 C-명령어](#c-command)          
[4.2.4 기호](#symbol)           
[4.2.5 입출력 조작](#io-manipulation)            
[4.2.6 구문 규칙과 파일 형식](#syntax-rules-and-file-types)                

# Machine Language

컴퓨터는 어떤 하드웨어 플랫폼을 저수준 칩들로 어떻게 구성했는지를 **구성적**으로 설명할 수 있다. 그리고 기계어의 함수들을 정의하고 사용법을 보여주는 방식으로 **추상적**으로 설명할 수 있다. 기계어 프로그램을 통해 하드웨어가 왜 이렇게 설계되었는지 이해하는데 도움이 된다.

기계어는 기계 수준의 명령어들로 이루어진 저수준 프로그램을 코딩할 수 있도록 미리 정의된 규칙으로 해당 하드웨어 플랫폼에서 직접적으로 명령을 실행하거나 하드웨어를 완전히 제어하는 것을 주요 목표로 삼는다. 

기계어는 전체 컴퓨터 시스템에서 가장 기본이 되는 인터페이스로 하드웨어와 소프트웨어가 만나는 접점이다. 즉 기계어는 프로그래밍 도구인 동시에 하드웨어 플랫폼의 구성 요소가 된다. 

## Background

### Machine

**기계어**는 프로세서와 레지스터들을 이용해서 메모리르 조작할 수 있도록 미리 정의된 규칙이라고 볼 수 있다.

#### 메모리

메모리는 컴퓨터에서 데이터와 명령어를 저장하는 하드웨어 장치들을 통칭하는 용어다. *'단어'* 나 *'위치'* 라고 불리는 정해진 폭의 셀들이 연속적으로 배열되어 각각에 유일한 *'주소'* 가 있는 구조다. 따라서 개별 단어는 주소를 통해 특징된다. 이러한 주소는 `Memory[address], RAM[address], M[address]` 로 표현한다.

#### 프로세서 

CPU 혹은 중앙 처리 장치라고 불리는 특정한 기초 연산들을 수행하는 장치다. 기초 연산은 산술 및 논리 연산, 메모리 접근 연산, 제어 연산이 포함된다. 이 연산의 피연산자는 선택된 메모리 위치와 레지스터에 있는 2진 값이다. 연산의 결과값은 선택된 메모리 주소나 레지스터에 저장된다.

#### 레지스터

레지스터는 프로세서 바로 엎에 위치해서, 프로세서가 명령어와 데이터를 빠르게 조작할 수 있도록 도와주는 로컬 고속 메모리의 역할을 수행한다. 

### Language

기계어 프로그램은 명령어들을 코드화 한 것으로 0101010101010101과 같이 표현된다. 이 명령의 뜻을 확인하려면 하드웨어 플랫폼의 명령 집합을 알아야 한다. 

기계어는 보통 **2진 코드**와 **연상기호**를 사용한다. 여기서 연상기호는 기호의 의미를 알기 쉽도록 힌트가 될 만한 이름으로 붙인 기호를 뜻한다. 예를 들어 2진 코드 1010을 ADD, 0101 주소의 레지스터를 R1, 1111 주소의 레지스터를 R2라고 명명한다면 101001011111을 ADD, R1, R2로 표기할 수 있다.

이 표기법을 한 단계 더 추상화하면, 이 기호들을 **읽기**만 하는 단계를 넘어 기호를 작성해서 **프로그램을 작성**할 수 있다. 이러한 방법을 **Assembly Language(어셈블리 언어)** 라고 부르고, 어셈블리를 2진 코드로 변환하는 프로그램을 **Assembler(어셈블러)** 라고 부른다. 어셈블러가 작동하는 과정은 다음과 같다.
```markdown
1. 기호 명령어들을 텍스트 처리 프로그램으로 분석
2. 필드(연상기호, 피연산자)를 식별
3. 각 필드를 동일한 의미의 2진 표현으로 변환
4. 전체 코드를 2진 기계 명령어로 번역
```

### Command

#### 산술 및 논리 연산

모든 컴퓨터는 기초 산술 연산 외에 Bit-Wise Negation(비트 반전), Bit Shifting(비트 이동) 등의 기본적인 불 연산도 가능해야 한다.

#### 메모리 접근

메모리 접근은 다음과 같이 두 가지로 분류된다.
```markdown
1. 산술 및 논리 명령은 레지스터 외 특정 메모리 주소에 접근 가능
2. 레지스터와 메모리 사이 데이터 이동 (load, store)
```

메모리 접근 명령은 메모리 주소를 특정하는 방법인 **주소 지정 모드**가 다양하게 존재한다.

##### Direct Addressing

**직접 주소 지정 방식**은 메모리에 접근하는 가장 일반적인 방법이다. 다음과 같이 그 주소를 나타내는 기호를 활용하는 방식을 사용한다.
```
LOAD R1, 67 // R1 <- Memory[67]
```

##### Immediate Addressing

**즉시 주소 지정 방식**은 명령어 코드에 있는 상수를 불러오는데 사용한다. 즉 명령어에 있는 숫자 필드를 주소로 취급하는 대신에 그 값 자체를 다음과 같이 레지스터로 로드한다.
```
LOAD R1, 67 // R1 <- 67
```

##### Indirect Addressing

**간접 주소 지정 방식**은 명령어에 메모리 주소가 하드코딩 되지 않는 대신 필요한 주소 값을 저장하고 있는 메모리 위치를 참조하는 명령어를 사용한다. 이는 하드웨어 적으로 다음과 같은 과정을 수행한다.
```markdown
0. foo : 배열변수, x,j : 정수 변수
1. 고수준 명령 x = foo[j] 실행
2. 고수준 프로그램에서 배열 foo를 정의하고 초기화
3. 컴파일러가 배열 데이터를 저장할 메모리 세그먼트 할당
4. foo 기호가 이 세그먼트의 시작 주소를 가리키도록 설정
5. foo 값에 j를 더한다. 
```
이러한 과정을 코드로 구현하면 다음과 같다.
```
ADD R1, foo, j // R1 <- foo + j
LOAD* R2, R1 // R2 <- Memory[R1]
STR R2, x // x <- R2
```

##### Flow of Control

프로그램은 종종 다른 위치로 **분기**해서 실행되기도 한다. 분기로는 다음과 같은 종류가 있다.
> **반복** : 루프의 시작으로 점프해서 돌아감        
  **조건 실행** : 불 조건이 거짓이면 'if else'절 다음의 위치로 점프       
  **서브루틴 호출** : 다른 코드 세그먼트의 첫 번째  멍령으로 점프       
  
모든 기계어는 이런 프로그래밍 구조를 지원하기 위해 다음과 같이 선택된 주소로 점프하는 기능을 포함하고 있다. 첫 번째 코드는 고수준 언어로 작성된 코드이고, 두 번째 코드는 첫 번째 코드를 저수준 언어로 변환한 코드이다.
```
while (R1 >= 0)
{
    code segment 1
}
code segment 2
```
```
beginWhile:
    JNG R1, endWhile // 만약 R1 < 0 면 endWhile로 이동
    (segment 1)
    JMP beginWhile // deginWhile로 이동
endWhile:

segment 2
```

JMP와 같은 **무조건 점프**명령에서는 가고자 하는 위치의 주소만 명시하면 된다. JNG와 같은 **조건 점프**명령은 불 조건을 어떤 식으로든 명시해 주어야 한다. 

## Specification

### Outline

앞으로 문서는 폰 노이만 플랫폼 기반의 CPU, 명령용과 데이터용으로 분리된 두 개의 메모리 모듈, 두 개의 메모리 매핑 I/O 장치(키보드, 모니터)로 구성된 16비트 장치를 기반으로 작성되었다.

#### 메모리 주소 공간

주소 공간을 **명령어 메모리**와 **데이터 메모리**로 분리한다. 폭이 16이기 때문에 메모리 주소 공간은 15비트가 된다.

CPU는 명령어 메모리에 존재하는 프로그램만 수행한다. 명령어 메모리는 읽기 전용으로 내부적인 방법으로는 프로그램을 로드할 수 없다. 예를 들어 콘솔 게임 칩과 같이 필요한 프로그램을 ROM 칩에 미리 새기는 방법이 있다. 이 방법은 ROM 칩을 새로 교체해야만 새로운 프로그램을 실행할 수 있다. 

이런 기능을 구현하기 위해 하드웨어 시뮬레이터에서는 이런 ROM 교체 방식을 시뮬레이션하기 위해, 텍스트 파일에 있는 기계어 프로그램을 명령어 메모리로 로드하는 기능을 제공한다. 

#### 레지스터



[4.2.2 A-명령어](#a-command)
[4.2.3 C-명령어](#c-command)
[4.2.4 기호](#symbol)
[4.2.5 입출력 조작](#io-manipulation)
[4.2.6 구문 규칙과 파일 형식](#syntax-rules-and-file-types)
